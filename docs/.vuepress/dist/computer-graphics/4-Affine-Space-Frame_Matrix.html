<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4 - Affine Space / Frame / Matrix</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/victor-mono@latest/dist/index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.css">
    <meta name="description" content="Summarizing key concepts from CS lectures.">
    
    <link rel="preload" href="/assets/css/0.styles.097f7555.css" as="style"><link rel="preload" href="/assets/js/app.3bcdd454.js" as="script"><link rel="preload" href="/assets/js/18.bb8e1e7a.js" as="script"><link rel="preload" href="/assets/js/2.ef20ac42.js" as="script"><link rel="preload" href="/assets/js/1.4f07d9c2.js" as="script"><link rel="preload" href="/assets/js/30.6deed893.js" as="script"><link rel="preload" href="/assets/js/22.6bbde796.js" as="script"><link rel="prefetch" href="/assets/js/10.ff1598d2.js"><link rel="prefetch" href="/assets/js/11.246a69bf.js"><link rel="prefetch" href="/assets/js/12.7df642e8.js"><link rel="prefetch" href="/assets/js/13.e57ac035.js"><link rel="prefetch" href="/assets/js/14.d4b79f85.js"><link rel="prefetch" href="/assets/js/15.ce937c3c.js"><link rel="prefetch" href="/assets/js/16.35cfa2fe.js"><link rel="prefetch" href="/assets/js/17.3e5e8f2f.js"><link rel="prefetch" href="/assets/js/19.2f7e28ae.js"><link rel="prefetch" href="/assets/js/20.321501ab.js"><link rel="prefetch" href="/assets/js/21.85cd1bb2.js"><link rel="prefetch" href="/assets/js/23.1c6b188d.js"><link rel="prefetch" href="/assets/js/24.bffcbf0e.js"><link rel="prefetch" href="/assets/js/25.a8628ef5.js"><link rel="prefetch" href="/assets/js/26.f69b21dd.js"><link rel="prefetch" href="/assets/js/27.b93cbfe2.js"><link rel="prefetch" href="/assets/js/28.bc755508.js"><link rel="prefetch" href="/assets/js/29.bb93d1d5.js"><link rel="prefetch" href="/assets/js/3.15216429.js"><link rel="prefetch" href="/assets/js/31.9cfd4e14.js"><link rel="prefetch" href="/assets/js/32.f572fc08.js"><link rel="prefetch" href="/assets/js/33.b5e6d889.js"><link rel="prefetch" href="/assets/js/34.9fade83f.js"><link rel="prefetch" href="/assets/js/35.646e59d5.js"><link rel="prefetch" href="/assets/js/4.107563ed.js"><link rel="prefetch" href="/assets/js/5.5467bfa0.js"><link rel="prefetch" href="/assets/js/6.c4de5fb4.js"><link rel="prefetch" href="/assets/js/7.4a5373f5.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.097f7555.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/kmbzn.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>🖥️ Computer Graphics</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/computer-graphics/1-Course-Intro.html" class="sidebar-link">1-Course-Intro</a></li><li><a href="/computer-graphics/2-Rendering-Basics.html" class="sidebar-link">2-Rendering-Basics</a></li><li><a href="/computer-graphics/3-Transformations-v2.html" class="sidebar-link">3-Transformations-v2</a></li><li><a href="/computer-graphics/4-Affine-Space-Frame_Matrix.html" aria-current="page" class="active sidebar-link">4-Affine-Space-Frame_Matrix</a></li><li><a href="/computer-graphics/5-Vertex-Processing-1.html" class="sidebar-link">5-Vertex-Processing-1</a></li><li><a href="/computer-graphics/6-Vertex-Processing-2.html" class="sidebar-link">6-Vertex-Processing-2</a></li><li><a href="/computer-graphics/7-Hierachical-Modeling-Mesh.html" class="sidebar-link">7-Hierachical-Modeling-Mesh</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_4-affine-space-frame-matrix"><a href="#_4-affine-space-frame-matrix" class="header-anchor">#</a> 4 - Affine Space / Frame / Matrix</h1> <h2 id="updates-in-prev-lecture-slides-rigid-transformations"><a href="#updates-in-prev-lecture-slides-rigid-transformations" class="header-anchor">#</a> Updates in Prev. Lecture Slides – Rigid Transformations</h2> <ul><li><p>모든 점 사이의 거리를 유지함<br>
∥g(u) − g(v)∥ = ∥u − v∥, ∀u, v ∈ ℝ³</p></li> <li><p>&quot;Handedness&quot;를 보존함</p> <ul><li>회전의 경우:<br>
g(u) × g(v) = g(u × v), ∀u, v ∈ ℝ³<br>
(reflection은 보존하지 않음)<br>
(translation은 방향을 바꾸지 않으므로 영향을 주지 않음)</li></ul></li> <li><p>일부 문헌에서는 reflection을 rigid transformation으로 분류하지만,<br>
본 강의에서는 포함하지 않음</p></li></ul> <h2 id="outline"><a href="#outline" class="header-anchor">#</a> Outline</h2> <ul><li>Affine Space - Point vs. Vector</li> <li>Coordinate System &amp; Reference Frame</li> <li>Affine Transformation Matrix</li> <li>Interpretation of Composite Transformations</li></ul> <h1 id="affine-space-point-vs-vector"><a href="#affine-space-point-vs-vector" class="header-anchor">#</a> Affine Space - Point vs. Vector</h1> <h2 id="affine-space-point-vs-vector-2"><a href="#affine-space-point-vs-vector-2" class="header-anchor">#</a> Affine Space - Point vs. Vector</h2> <ul><li><p>개념적으로 <strong>point와 vector는 매우 다름</strong></p></li> <li><p>이 차이는 <strong>homogeneous coordinates</strong>로 표현할 수 있음</p></li> <li><p>이 강의에서는 affine space,<br> <strong>point와 vector의 차이점</strong>,<br>
그리고 그것이 homogeneous coordinates와<br>
어떻게 연결되는지를 학습함</p></li> <li><p>이 개념은 coordinate invariant 또는<br>
coordinate-free geometric programming이라고도 불림</p></li></ul> <p>(출처: http://mrl.snu.ac.kr/courses/CourseGraphics/index_2017spring.html)</p> <h2 id="points"><a href="#points" class="header-anchor">#</a> Points</h2> <ul><li><p>Point p, Point q</p></li> <li><p>이 두 점을 더한 **“sum”**은 무엇인가?</p></li></ul> <h2 id="if-you-assume-coordinates"><a href="#if-you-assume-coordinates" class="header-anchor">#</a> If you assume coordinates, …</h2> <ul><li><p>p = (x₁, y₁), q = (x₂, y₂)</p></li> <li><p>합: (x₁ + x₂, y₁ + y₂)</p></li></ul> <p>→ 이게 맞는가?<br>
→ <strong>기하학적으로 의미가 있는가?</strong></p> <h2 id="if-you-assume-coordinates-2"><a href="#if-you-assume-coordinates-2" class="header-anchor">#</a> If you assume coordinates, …</h2> <ul><li><p>동일한 좌표 표현에서,</p></li> <li><p>p = (x₁, y₁), q = (x₂, y₂)</p></li> <li><p>(x₁ + x₂, y₁ + y₂)는 단순한 합이 아닌,<br> <strong>원점에서 p와 q까지 가는 vector의 합</strong>으로 간주해야 함</p></li></ul> <p>→ <strong>Vector sum</strong></p> <h2 id="if-you-select-a-different-origin"><a href="#if-you-select-a-different-origin" class="header-anchor">#</a> If you select a different origin, …</h2> <ul><li><p>p = (x₁, y₁), q = (x₂, y₂)</p></li> <li><p>(x₁ + x₂, y₁ + y₂)의 의미는<br> <strong>좌표계(원점)가 어디인지에 따라 달라짐</strong></p></li> <li><p>즉, <strong>다른 coordinate frame을 선택하면 결과도 달라짐</strong></p></li></ul> <h2 id="points-and-vectors"><a href="#points-and-vectors" class="header-anchor">#</a> Points and Vectors</h2> <ul><li><p><strong>point</strong>는 좌표값으로 정의된 위치</p></li> <li><p><strong>vector</strong>는 두 점 사이의 차이로 정의됨</p></li> <li><p>원점이 정의되었다면, point는<br>
원점에서 해당 point까지의 <strong>vector로 표현 가능</strong></p></li> <li><p>하지만 coordinate-free 관점에서는<br> <strong>point는 vector가 아님</strong></p></li></ul> <h2 id="points-vectors-are-different"><a href="#points-vectors-are-different" class="header-anchor">#</a> Points &amp; Vectors are Different!</h2> <ul><li><p>수학적(또는 물리적)으로,</p> <ul><li><strong>Point는 공간상의 위치</strong></li> <li><strong>Vector는 공간상의 변위</strong></li></ul></li> <li><p>시간에 비유하면 다음과 같음:</p> <ul><li><strong>datetime은 시간의 위치</strong></li> <li><strong>duration은 시간의 변위</strong></li></ul></li></ul> <h2 id="vector-and-affine-spaces"><a href="#vector-and-affine-spaces" class="header-anchor">#</a> Vector and Affine Spaces</h2> <ul><li><p><strong>Vector space</strong></p> <ul><li>벡터와 그 연산 포함</li> <li>점은 포함하지 않음</li></ul></li> <li><p><strong>Affine space</strong></p> <ul><li>vector space의 상위 개념</li> <li>벡터, 점, 그에 관련된 연산 모두 포함</li></ul></li></ul> <h2 id="vector-spaces"><a href="#vector-spaces" class="header-anchor">#</a> Vector spaces</h2> <ul><li><p>A <strong>vector space</strong>는 다음으로 구성됨:</p> <ul><li>벡터 집합과</li> <li>두 가지 연산:
<ul><li>벡터 간 덧셈</li> <li>스칼라 곱</li></ul></li></ul></li> <li><p><strong>벡터들의 선형 결합(linear combination)</strong> 또한 벡터임</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>u₀, u₁, ..., uₙ ∈ V ⇒  
c₀u₀ + c₁u₁ + ... + cₙuₙ ∈ V
</code></pre></div><h2 id="affine-spaces"><a href="#affine-spaces" class="header-anchor">#</a> Affine Spaces</h2> <ul><li><p>An <strong>affine space</strong>는 다음으로 구성됨:</p> <ul><li>점들의 집합, 관련된 벡터 공간,</li> <li>두 가지 연산:
<ul><li>두 점의 차</li> <li>점 + 벡터</li></ul></li></ul></li></ul> <h2 id="coordinate-free-geometric-operations"><a href="#coordinate-free-geometric-operations" class="header-anchor">#</a> Coordinate-Free Geometric Operations</h2> <ul><li>덧셈 (Addition)</li> <li>뺄셈 (Subtraction)</li> <li>스칼라 곱 (Scalar multiplication)</li></ul> <h2 id="addition"><a href="#addition" class="header-anchor">#</a> Addition</h2> <ul><li><p>u + v → <strong>벡터</strong></p></li> <li><p>p + w → <strong>점</strong></p></li> <li><p>u, v, w: vectors</p></li> <li><p>p, q: points</p></li></ul> <h2 id="subtraction"><a href="#subtraction" class="header-anchor">#</a> Subtraction</h2> <ul><li>u − v → 벡터</li> <li>p − q → 벡터</li> <li>p − w → 점</li></ul> <p>(단, u, v, w: vectors / p, q: points)</p> <h2 id="scalar-multiplication"><a href="#scalar-multiplication" class="header-anchor">#</a> Scalar Multiplication</h2> <ul><li><strong>스칼라 × 벡터 = 벡터</strong></li> <li><strong>1 × 점 = 점</strong></li> <li><strong>0 × 점 = 벡터</strong></li> <li><strong>c × 점 = 정의되지 않음</strong> (단, c ≠ 0, 1일 때)</li></ul> <h2 id="affine-frame"><a href="#affine-frame" class="header-anchor">#</a> Affine Frame</h2> <ul><li><p>A <strong>frame</strong>은 다음으로 정의됨:</p> <ul><li>벡터들의 집합 {vᵢ}, i = 1, ..., N</li> <li>기준이 되는 점 o</li></ul></li> <li><p>{vᵢ}는 해당 vector space의 <strong>basis</strong></p></li> <li><p>o는 해당 frame의 <strong>origin</strong></p></li> <li><p>N은 affine space의 <strong>차원</strong></p></li> <li><p>임의의 점 p는 다음과 같이 표현됨:</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>p = o + c₁v₁ + c₂v₂ + ... + cₙvₙ
</code></pre></div><ul><li>임의의 벡터 v는 다음과 같이 표현됨:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>v = c₁v₁ + c₂v₂ + ... + cₙvₙ
</code></pre></div><h2 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h2> <ul><li>Affine space에서:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>point + point = 정의되지 않음  
point − point = vector  
point + vector = point  
vector + vector = vector  
scalar × vector = vector  
scalar × point =  
  - point (if scalar = 1)  
  - vector (if scalar = 0)  
  - undefined (otherwise)
</code></pre></div><h2 id="points-vectors-in-homogeneous-coordinates"><a href="#points-vectors-in-homogeneous-coordinates" class="header-anchor">#</a> Points &amp; Vectors in Homogeneous Coordinates</h2> <ul><li><p>Homogeneous coordinates에서는,</p> <ul><li><strong>3D point</strong>: (x, y, z, <strong>1</strong>)</li> <li><strong>3D vector</strong>: (x, y, z, <strong>0</strong>)</li></ul></li></ul> <p>→ 이 표현은 coordinate-free geometric programming의<br>
개념과 <strong>완전하게 일치하는 모델</strong>을 제공함</p> <h2 id="points-vectors-in-homogeneous-coordinates-2"><a href="#points-vectors-in-homogeneous-coordinates-2" class="header-anchor">#</a> Points &amp; Vectors in Homogeneous Coordinates</h2> <p>예시:</p> <div class="language- extra-class"><pre class="language-text"><code>( x₁, y₁, z₁, 1 ) + ( x₂, y₂, z₂, 1 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 2 ) → point (정의 안 됨)  
( x₁, y₁, z₁, 1 ) − ( x₂, y₂, z₂, 1 ) = ( x₁ − x₂, y₁ − y₂, z₁ − z₂, 0 ) → vector  
( x₁, y₁, z₁, 1 ) + ( x₂, y₂, z₂, 0 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 1 ) → point  
( x₁, y₁, z₁, 0 ) + ( x₂, y₂, z₂, 0 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 0 ) → vector  
c × ( x, y, z, 0 ) = ( cx, cy, cz, 0 ) → vector  
c × ( x, y, z, 1 ) = ( cx, cy, cz, c ) →  
  - point (if c = 1)  
  - undefined (if c ≠ 0,1)
</code></pre></div><h2 id="points-vectors-in-homogeneous-coordinates-3"><a href="#points-vectors-in-homogeneous-coordinates-3" class="header-anchor">#</a> Points &amp; Vectors in Homogeneous Coordinates</h2> <ul><li>Affine transformation matrix × point, vector:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>[ M  t ]   [ p ]   = [ M * p + t ] → point  
[ 0ᵀ 1 ]   [ 1 ]             [ 1 ]

[ M  t ]   [ v ]   = [ M * v     ] → vector  
[ 0ᵀ 1 ]   [ 0 ]             [ 0 ]
</code></pre></div><p>→ <strong>translation은 vector에는 적용되지 않음!</strong></p> <h2 id="quiz-1"><a href="#quiz-1" class="header-anchor">#</a> Quiz 1</h2> <h1 id="coordinate-system-reference-frame"><a href="#coordinate-system-reference-frame" class="header-anchor">#</a> Coordinate System &amp; Reference Frame</h1> <h2 id="coordinate-system-reference-frame-2"><a href="#coordinate-system-reference-frame-2" class="header-anchor">#</a> Coordinate System &amp; Reference Frame</h2> <ul><li><p><strong>Coordinate system</strong></p> <ul><li>점의 위치를 고유하게 결정하기 위해<br>
하나 이상의 숫자 또는 좌표를 사용하는 체계</li></ul></li> <li><p><strong>Reference frame</strong></p> <ul><li>추상적인 좌표계 + 실제 기준점</li> <li>좌표계를 고정시키기 위해 사용됨</li></ul></li> <li><p>이 두 용어는 종종 혼용되지만,<br> <strong>의미에는 약간의 차이</strong>가 있음</p></li></ul> <h2 id="world-body-frame-or-coordinate-system"><a href="#world-body-frame-or-coordinate-system" class="header-anchor">#</a> World / Body Frame (or Coordinate System)</h2> <ul><li><p><strong>World frame (or coordinate system)</strong></p> <ul><li>세계에 고정된 좌표계</li> <li>aka. global frame, fixed frame</li></ul></li> <li><p><strong>Body frame (or coordinate system)</strong></p> <ul><li>물체에 고정된 좌표계</li> <li>aka. local frame</li></ul></li></ul> <p>(예시 이미지: world frame과 body frame의 차이)</p> <h1 id="affine-transformation-matrix"><a href="#affine-transformation-matrix" class="header-anchor">#</a> Affine Transformation Matrix</h1> <h2 id="meanings-of-affine-transformation-matrix"><a href="#meanings-of-affine-transformation-matrix" class="header-anchor">#</a> Meanings of Affine Transformation Matrix</h2> <ul><li><strong>하나의 affine transformation matrix</strong>는<br> <strong>여러 관점에서 해석 가능함</strong></li></ul> <h2 id="_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame"><a href="#_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame" class="header-anchor">#</a> 1) Affine Transformation Matrix Transforms a Geometry w.r.t. World Frame</h2> <ul><li><p>행렬 M은 <strong>기하 객체의 각 vertex 위치를</strong><br> <strong>world frame 기준에서 새로운 위치로 변환</strong></p></li> <li><p>변환 포함: translate, rotate, scale 등</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>M =
[ m11  m12  m13  tx ]  
[ m21  m22  m23  ty ]  
[ m31  m32  m33  tz ]  
[  0    0    0   1  ]
</code></pre></div><ul><li>M을 곱하면 geometry가 world frame에서<br> <strong>다른 위치로 이동된 결과를 얻음</strong></li></ul> <h2 id="review-affine-frame"><a href="#review-affine-frame" class="header-anchor">#</a> Review: Affine Frame</h2> <ul><li><p><strong>Affine frame</strong> (3D 공간 기준)은 다음으로 정의됨:</p> <ul><li>x, y, z 축을 나타내는 3개의 벡터</li> <li>1개의 원점 위치</li></ul></li></ul> <p>(도식: 세 벡터 + 한 점)</p> <h2 id="world-frame"><a href="#world-frame" class="header-anchor">#</a> World Frame</h2> <ul><li><p><strong>World frame</strong>은 보통 다음으로 표현됨:</p> <ul><li>표준 축 벡터
<ul><li>êₓ = [1 0 0]ᵀ</li> <li>êᵧ = [0 1 0]ᵀ</li> <li>ê𝓏 = [0 0 1]ᵀ</li></ul></li> <li>원점 위치: 0</li></ul></li></ul> <p>(도식: 원점에서 출발하는 세 축 벡터)</p> <h2 id="let-s-transform-a-world-frame"><a href="#let-s-transform-a-world-frame" class="header-anchor">#</a> Let’s transform a &quot;world frame&quot;</h2> <ul><li>M을 <strong>world frame에 곱하면</strong>,<br>
x, y, z 축 벡터 및 원점에 각각 곱해지며 프레임이 변환됨:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>x axis vector:
M × [1 0 0 0]ᵀ = 첫 번째 column  
y axis vector:
M × [0 1 0 0]ᵀ = 두 번째 column  
z axis vector:
M × [0 0 1 0]ᵀ = 세 번째 column  
origin point:
M × [0 0 0 1]ᵀ = 네 번째 column
</code></pre></div><h2 id="_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"><a href="#_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame" class="header-anchor">#</a> 2) Affine Transformation Matrix Defines an Affine Frame w.r.t. World Frame</h2> <ul><li><p>행렬 M은 <strong>Affine Frame을 정의함</strong></p> <ul><li>(기준 프레임 {0} 기준으로 표현된 {1} 프레임)</li></ul></li> <li><p>M의 각 column은 다음을 나타냄:</p> <ul><li>첫 3개 column: 축 벡터</li> <li>마지막 column: 원점 위치</li></ul></li></ul> <p>→ M은 <strong>변환된 body frame {1}을 world frame {0} 기준으로 표현한 것</strong></p> <h2 id="examples"><a href="#examples" class="header-anchor">#</a> Examples</h2> <ul><li><p>같은 물체의 body frame이 두 가지 방식으로 정의됨:</p> <ul><li>(a) world frame과 body frame이 일치할 때</li> <li>(b) body frame이 다른 위치에서 정의될 때</li></ul></li></ul> <p>→ 두 경우 모두 M은 body frame을 world frame 기준으로 표현함</p> <h2 id="_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame"><a href="#_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame" class="header-anchor">#</a> 3) Affine Transformation Matrix Transforms a Point Represented in an Affine Frame to the Same Point (but) Represented in World Frame</h2> <ul><li>p^{(1)} = (1, 1, 0): body frame {1} 기준에서 본 점</li> <li>M을 곱하면:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>p^{(0)} = M * p^{(1)}
</code></pre></div><ul><li>즉, 같은 점을 world frame {0} 기준에서 표현한 것</li></ul> <h2 id="_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame-because"><a href="#_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame-because" class="header-anchor">#</a> 3) Affine Transformation Matrix Transforms a Point Represented in an Affine Frame to the Same Point (but) Represented in World Frame Because...</h2> <ul><li>동일한 물체를 body frame 기준에서 보다가<br>
M을 통해 <strong>world frame 기준 표현</strong>으로 변환한 것</li></ul> <div class="language- extra-class"><pre class="language-text"><code>p^{(0)} = M * p^{(1)}
</code></pre></div><ul><li>단순히 geometry를 변환한 이야기임</li></ul> <h2 id="directions-of-the-arrow"><a href="#directions-of-the-arrow" class="header-anchor">#</a> Directions of the &quot;arrow&quot;</h2> <ul><li><strong>첫 번째 의미 (1st meaning)</strong> <ul><li>geometry 자체를 transform (frame은 그대로)</li> <li>M은 변환의 방향을 나타냄: {0} → {1}</li></ul></li></ul> <p>→ p^{(1)}가 변환되어 p^{(0)}이 됨</p> <h2 id="directions-of-the-arrow-2"><a href="#directions-of-the-arrow-2" class="header-anchor">#</a> Directions of the &quot;arrow&quot;</h2> <ul><li><p><strong>두 번째 의미는 frame 자체의 변환</strong></p> <ul><li>{1} 프레임이 {0} 기준으로 어떻게 보이는지를 나타냄</li></ul></li> <li><p><strong>세 번째 의미 (3rd meaning)</strong></p> <ul><li><strong>p라는 점이 표현되는 프레임 자체를 바꾸는 과정</strong></li></ul></li></ul> <p>→ &quot;표현의 기준&quot;이 바뀜: {1}에서 본 p를<br>
{0}에서 본 p로 변환하는 것</p> <h2 id="quiz-2"><a href="#quiz-2" class="header-anchor">#</a> Quiz 2</h2> <h2 id="all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame"><a href="#all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame" class="header-anchor">#</a> All these concepts work even if the starting frame is not world frame!</h2> <ul><li>시작 프레임이 world frame이 아니어도, 지금까지의 모든 개념은 그대로 적용 가능</li></ul> <h2 id="_0-to-1"><a href="#_0-to-1" class="header-anchor">#</a> {0} to {1}</h2> <ul><li><p>M₁은 다음을 수행:</p> <ol><li>프레임 {0} 기준에서 geometry를 변환</li> <li>프레임 {0} 기준에서 프레임 {1}을 정의</li> <li>프레임 {1} 기준의 점을 {0} 기준으로 표현
<ul><li>p^{(0)} = M₁ * p^{(1)}</li></ul></li></ol></li></ul> <h2 id="_1-to-2"><a href="#_1-to-2" class="header-anchor">#</a> {1} to {2}</h2> <ul><li><p>M₂는 다음을 수행:</p> <ol><li>프레임 {1} 기준에서 geometry를 변환</li> <li>프레임 {1} 기준에서 프레임 {2}를 정의</li> <li>프레임 {2} 기준의 점을 {1} 기준으로 표현
<ul><li>p^{(1)} = M₂ * p^{(2)}</li></ul></li></ol></li></ul> <h2 id="_0-to-2"><a href="#_0-to-2" class="header-anchor">#</a> {0} to {2}</h2> <ul><li><p>M₁M₂는 다음을 수행:</p> <ol><li>프레임 {0} 기준에서 geometry를 변환</li> <li>프레임 {0} 기준에서 프레임 {2}를 정의</li> <li>프레임 {2} 기준의 점을 {0} 기준으로 표현
<ul><li>p^{(0)} = M₁ * M₂ * p^{(2)}</li></ul></li></ol></li></ul> <h1 id="interpretation-of-composite-transformations"><a href="#interpretation-of-composite-transformations" class="header-anchor">#</a> Interpretation of Composite Transformations</h1> <h2 id="revisit-order-matters"><a href="#revisit-order-matters" class="header-anchor">#</a> Revisit: Order Matters!</h2> <ul><li>T, R이 affine transformation을 나타내는 행렬일 때:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>p' = T * R * p
  → 먼저 R 적용 (p → R(p)), 그 후 T 적용

p' = R * T * p
  → 먼저 T 적용 (p → T(p)), 그 후 R 적용
</code></pre></div><ul><li>→ <strong>행렬의 곱셈 순서는 매우 중요함!</strong> <ul><li>곱셈은 결합법칙은 성립하지만 교환법칙은 성립하지 않음 (AB ≠ BA)</li></ul></li></ul> <h2 id="interpretation-of-composite-transformations-1"><a href="#interpretation-of-composite-transformations-1" class="header-anchor">#</a> Interpretation of Composite Transformations #1</h2> <ul><li><p>예제 변환:<br>
M = T(x,3) · R(−90°)</p></li> <li><p>우리가 지금까지 해석한 방식:</p> <ul><li><strong>R → T 순서로</strong> 적용</li> <li>R은 world frame 기준 변환</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>p → R(−90°)(p) → T(x,3) 적용 → p' = T(R(p))
</code></pre></div><h2 id="interpretation-of-composite-transformations-2"><a href="#interpretation-of-composite-transformations-2" class="header-anchor">#</a> Interpretation of Composite Transformations #2</h2> <ul><li><p>예제 변환 동일:<br>
M = T(x,3) · R(−90°)</p></li> <li><p><strong>다른 해석 방식</strong>:</p> <ul><li>R → T 순서가 아닌, <strong>T → R</strong> 순서로 해석</li> <li>즉, <strong>body frame 기준</strong>에서 해석하는 방식</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>p → T(p) → R(T(p)) = M(p) = p'
</code></pre></div><ul><li>→ 동일한 행렬이라도 <strong>기준 프레임에 따라 해석이 달라질 수 있음</strong></li></ul> <h2 id="pre-left-post-right-multiplication"><a href="#pre-left-post-right-multiplication" class="header-anchor">#</a> Pre-(left) &amp; Post-(right) Multiplication</h2> <div class="language- extra-class"><pre class="language-text"><code>p' = M₁M₂p  (pre-multiplication by M₁)
→ R-to-L 순서
</code></pre></div><ol><li>M₂를 <strong>world frame 기준</strong>으로 적용하여 p를 변환</li> <li>그 결과를 M₁을 통해 <strong>world frame 기준</strong>으로 다시 변환</li></ol> <p>→ 전체 변환은 <strong>M₁M₂</strong></p> <hr> <div class="language- extra-class"><pre class="language-text"><code>p' = M₁M₂p  (post-multiplication by M₁)
→ L-to-R 순서
</code></pre></div><ol><li>p는 body frame {1} 기준에서 표현되어 있고,<br>
M₁은 <strong>body frame {1}을 world frame 기준으로 업데이트</strong>함</li> <li>M₂는 body frame {2}로 업데이트함</li> <li>결과적으로 p는 body frame {2}에서 표현됨</li></ol> <p>→ 전체 변환은 <strong>M₁M₂</strong></p> <p><strong>또 다른 유용한 해석법</strong></p> <ol><li>M₁을 world frame 기준으로 적용하여 <strong>body frame을 M₁으로 업데이트</strong></li> <li>M₂를 world frame 기준으로 적용하여 <strong>body frame을 M₁M₂로 업데이트</strong></li> <li>p를 새 body frame M₁M₂ 기준으로 위치시킴</li></ol> <h2 id="demo-l-to-r-r-to-l-interpretation"><a href="#demo-l-to-r-r-to-l-interpretation" class="header-anchor">#</a> [Demo] L-to-R &amp; R-to-L Interpretation</h2> <p>https://observablehq.com/@esperanc/transformation-demo</p> <ul><li>다양한 순서로 translation 및 선형 변환 추가 ( '+' 버튼 사용)</li> <li>슬라이더를 드래그하여 행렬 값의 변화 및 도형의 변화를 관찰</li> <li>합성 변환의 의미를 <strong>L-to-R</strong>, <strong>R-to-L</strong> 순서로 해석해보세요</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2025/5/4 07:38:38</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/computer-graphics/3-Transformations-v2.html" class="prev">
        3-Transformations-v2
      </a></span> <span class="next"><a href="/computer-graphics/5-Vertex-Processing-1.html">
        5-Vertex-Processing-1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.3bcdd454.js" defer></script><script src="/assets/js/18.bb8e1e7a.js" defer></script><script src="/assets/js/2.ef20ac42.js" defer></script><script src="/assets/js/1.4f07d9c2.js" defer></script><script src="/assets/js/30.6deed893.js" defer></script><script src="/assets/js/22.6bbde796.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>3 - Transformations</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
      if (typeof window !== 'undefined') {
        window.addEventListener("DOMContentLoaded", function () {
          renderMathInElement(document.body, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
            ],
            throwOnError: false
          });
        });
      }
    </script>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/images/android-chrome-512x512.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/victor-mono@latest/dist/index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.css">
    <meta name="description" content="Summarizing key concepts from CS lectures.">
    <meta property="og:description" content="by kmbzn">
    <meta property="og:image" content="https://kmbzn.com/images/og-home.png">
    
    <link rel="preload" href="/assets/css/0.styles.357a6061.css" as="style"><link rel="preload" href="/assets/js/app.4280e306.js" as="script"><link rel="preload" href="/assets/js/18.bb8e1e7a.js" as="script"><link rel="preload" href="/assets/js/2.a3ccddde.js" as="script"><link rel="preload" href="/assets/js/1.93e900e1.js" as="script"><link rel="preload" href="/assets/js/29.4d7b2591.js" as="script"><link rel="preload" href="/assets/js/20.9f752867.js" as="script"><link rel="preload" href="/assets/js/22.6bbde796.js" as="script"><link rel="prefetch" href="/assets/js/10.6637bfee.js"><link rel="prefetch" href="/assets/js/11.89241896.js"><link rel="prefetch" href="/assets/js/12.1f81aafc.js"><link rel="prefetch" href="/assets/js/13.db5eb42a.js"><link rel="prefetch" href="/assets/js/14.a654c061.js"><link rel="prefetch" href="/assets/js/15.82f66eb5.js"><link rel="prefetch" href="/assets/js/16.41334cbf.js"><link rel="prefetch" href="/assets/js/17.9f4ed163.js"><link rel="prefetch" href="/assets/js/19.6965bf28.js"><link rel="prefetch" href="/assets/js/21.85cd1bb2.js"><link rel="prefetch" href="/assets/js/23.1c6b188d.js"><link rel="prefetch" href="/assets/js/24.bffcbf0e.js"><link rel="prefetch" href="/assets/js/25.bf3894f9.js"><link rel="prefetch" href="/assets/js/26.aee70adc.js"><link rel="prefetch" href="/assets/js/27.81d367b1.js"><link rel="prefetch" href="/assets/js/28.de6125f3.js"><link rel="prefetch" href="/assets/js/3.7e2f5075.js"><link rel="prefetch" href="/assets/js/30.aceee2fb.js"><link rel="prefetch" href="/assets/js/31.fea3010b.js"><link rel="prefetch" href="/assets/js/32.05970350.js"><link rel="prefetch" href="/assets/js/33.cb063db1.js"><link rel="prefetch" href="/assets/js/34.f4137101.js"><link rel="prefetch" href="/assets/js/35.646e59d5.js"><link rel="prefetch" href="/assets/js/4.107563ed.js"><link rel="prefetch" href="/assets/js/5.5467bfa0.js"><link rel="prefetch" href="/assets/js/6.e9ea9ee0.js"><link rel="prefetch" href="/assets/js/7.4a5373f5.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.357a6061.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/kmbzn.png" alt="" class="logo"> <!----></a> <div class="links"><!----> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>🖥️ Computer Graphics</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/computer-graphics/1-Course-Intro.html" class="sidebar-link">1-Course-Intro</a></li><li><a href="/computer-graphics/2-Rendering-Basics.html" class="sidebar-link">2-Rendering-Basics</a></li><li><a href="/computer-graphics/3-Transformations.html" aria-current="page" class="active sidebar-link">3-Transformations</a></li><li><a href="/computer-graphics/4-Affine-Space-Frame_Matrix.html" class="sidebar-link">4-Affine-Space-Frame_Matrix</a></li><li><a href="/computer-graphics/5-Vertex-Processing-1.html" class="sidebar-link">5-Vertex-Processing-1</a></li><li><a href="/computer-graphics/6-Vertex-Processing-2.html" class="sidebar-link">6-Vertex-Processing-2</a></li><li><a href="/computer-graphics/7-Hierachical-Modeling-Mesh.html" class="sidebar-link">7-Hierachical-Modeling-Mesh</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_3-transformations"><a href="#_3-transformations" class="header-anchor">#</a> 3 - Transformations</h1> <h2 id="outline"><a href="#outline" class="header-anchor">#</a> Outline</h2> <ul><li><p>2차원 변환</p> <ul><li>Scaling, Rotation, Shearing, Reflection</li> <li>Translation</li></ul></li> <li><p>변환의 종류</p></li> <li><p>변환의 합성과 Homogeneous Coordinates</p></li> <li><p>두 가지 3차원 직교 좌표계</p></li> <li><p>3차원 Affine 변환</p></li></ul> <h2 id="what-is-transformation"><a href="#what-is-transformation" class="header-anchor">#</a> What is Transformation?</h2> <ul><li><p>Geometric <strong>Transformation</strong></p> <ul><li><p>기하학적 object의 위치, 방향, 크기 또는 형태를 수학적으로 변경하는 과정<br>
→ “점들의 집합을 이동시키는 것”</p></li> <li><p>복잡한 장면과 애니메이션 생성을 가능하게 함</p></li> <li><p>Computer graphics에서 필수적임</p></li></ul></li> <li><p>예시:</p> <ul><li>Translate</li> <li>Rotate</li> <li>Scale</li> <li>Shear</li> <li>Reflect</li></ul></li></ul> <h2 id="transformation"><a href="#transformation" class="header-anchor">#</a> Transformation</h2> <ul><li><p>“점들의 집합을 이동시키는 것”</p></li> <li><p>Transformation T는 벡터 공간 S에 있는 임의의 입력 벡터 v를 T(v)로 사상(寫像)함</p> <p>수식 표현: $S \rightarrow \{~ T(v) \mid v \in S ~\}$</p></li></ul> <h2 id="linear-transformation"><a href="#linear-transformation" class="header-anchor">#</a> Linear Transformation</h2> <ul><li><p>행렬 곱을 통해 Transformation을 정의할 수 있음</p> <p>$$
T(\mathbf{v}) = M\mathbf{v}
$$</p></li> <li><p>이는 행렬 곱셈이 선형 사상(寫像)을 나타내게 되므로<br> <strong>linear transformation</strong>이라 부름</p></li> <li><p>Linear transformation은 다음 조건을 만족해야 함:</p> <p>$$
T(\mathbf{v}_1 + \mathbf{v}_2) \\ = T(\mathbf{v}_1) + T(\mathbf{v}_2), \quad T(c\mathbf{v}) \\ = cT(\mathbf{v})
$$</p></li> <li><p>행렬 $M$ 또한 동일한 *선형성(linearity)*을 만족:</p> <p>$$
M(\mathbf{v}_1 + \mathbf{v}_2) \\ = M\mathbf{v}_1 + M\mathbf{v}_2, \quad M(c\mathbf{v}) \\ = c(M\mathbf{v})
$$</p></li></ul> <h2 id="_2d-linear-transformations"><a href="#_2d-linear-transformations" class="header-anchor">#</a> 2D Linear Transformations</h2> <ul><li><p>2×2 행렬은 다음과 같은 2차원 linear transformation을 표현할 수 있음:</p> <ul><li>uniform scaling</li> <li>non-uniform scaling</li> <li>rotation</li> <li>shearing</li> <li>reflection</li></ul></li></ul> <h2 id="_2d-linear-trans-uniform-scaling"><a href="#_2d-linear-trans-uniform-scaling" class="header-anchor">#</a> 2D Linear Trans. – Uniform Scaling</h2> <ul><li>x축과 y축 모두에서 동일한 비율로 확대 또는 축소</li></ul> <p>$$
\mathbf{S} =
\begin{bmatrix}
s &amp; 0 \\
0 &amp; s
\end{bmatrix} \\<br>
\quad
\mathbf{p} =
\begin{bmatrix}
x \\
y
\end{bmatrix}
\quad\Rightarrow\quad
\mathbf{p}' =
\begin{bmatrix}
sx \\
sy
\end{bmatrix}
$$</p> <ul><li>예: 배율 ( s = 1.5 )인 scaling을 적용할 경우,</li></ul> <p>$$
\begin{bmatrix}
1.5 &amp; 0 \\
0 &amp; 1.5
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix} =
\begin{bmatrix}
1.5x \\
1.5y
\end{bmatrix}
$$</p> <h2 id="_2d-linear-trans-nonuniform-scaling"><a href="#_2d-linear-trans-nonuniform-scaling" class="header-anchor">#</a> 2D Linear Trans. – Nonuniform Scaling</h2> <ul><li>$x$축과 $y$축 방향으로 <strong>서로 다른 비율로</strong> 확대 또는 축소</li></ul> <p>$$
\begin{bmatrix}
s_x &amp; 0 \\
0 &amp; s_y
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix} =
\begin{bmatrix}
s_xx \\
s_yy
\end{bmatrix}
$$</p> <p>(예: $s_x$ = 1.5, $s_y$ = 0.8 → $x$축 방향은 확대, $y$축 방향은 축소)</p> <h2 id="_2d-linear-trans-rotation"><a href="#_2d-linear-trans-rotation" class="header-anchor">#</a> 2D Linear Trans. – Rotation</h2> <ul><li><p>회전은 행렬 곱으로 표현 가능하며, 따라서 <strong>선형 변환</strong>임</p></li> <li><p>양의 각도는 반시계 방향(CCW, Counter-Clockwise)을 의미함</p></li></ul> <p>$$
\begin{bmatrix}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix} =
\begin{bmatrix}
x \cos \theta - y \sin \theta \\
x \sin \theta + y \cos \theta
\end{bmatrix}
$$</p> <p>(예: $\theta = 30\degree$ → 30도 반시계 회전)</p> <h2 id="numbers-in-matrices-scaling-rotation"><a href="#numbers-in-matrices-scaling-rotation" class="header-anchor">#</a> Numbers in Matrices: Scaling, Rotation</h2> <ul><li><p>행렬의 <strong>각 숫자는 어떤 의미를 가질까?</strong></p></li> <li><p>단위 벡터$([1, 0]^T, [0, 1]^T)$을 기준으로 scaling 또는 rotation 시 각각의 column vector가 변환된 축의 방향을 나타냄</p></li> <li><p>Canonical basis vectors: 직교 좌표계에서 x, y축 방향 단위 벡터</p></li> <li><p>결과적으로, 변환된 좌표계의 축 방향을 나타냄</p></li> <li><p>행렬의 <strong>column vector</strong>는 그 행렬의 column space를 구성하는 <strong>basis vectors</strong></p></li> <li><p><em>Column space</em>: column vector들의 선형 결합으로 표현 가능한 모든 벡터의 집합</p></li></ul> <h2 id="_2d-linear-trans-reflection"><a href="#_2d-linear-trans-reflection" class="header-anchor">#</a> 2D Linear Trans. – Reflection</h2> <ul><li><p>Reflection은 <strong>non-uniform scaling의 특수한 경우</strong>로 간주할 수 있음</p></li> <li><p>예시: $x$축 방향 reflection</p></li></ul> <p>$$
\begin{bmatrix}
-1 &amp; 0\\
0 &amp; 1
\end{bmatrix}
$$</p> <h2 id="_2d-linear-trans-shearing"><a href="#_2d-linear-trans-shearing" class="header-anchor">#</a> 2D Linear Trans. – Shearing</h2> <ul><li><p>물체를 <strong>측면으로 밀기(push sideways)</strong></p></li> <li><p>예시: $x$축 기준으로 $y$에 비례하여 $x$ 이동</p></li></ul> <p>$$
\begin{bmatrix}
-1 &amp; 0\\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix} =
\begin{bmatrix}
x+ay\\
y
\end{bmatrix}
$$</p> <h2 id="identity-matrix"><a href="#identity-matrix" class="header-anchor">#</a> Identity Matrix</h2> <ul><li>아무런 변환도 수행하지 않는 행렬 → <strong>&quot;Doing nothing&quot;</strong></li></ul> <p>$$
\begin{bmatrix}
1 &amp; 0\\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix} =
\begin{bmatrix}
x\\
y
\end{bmatrix}
$$</p> <p>(도형의 위치, 크기, 방향이 유지됨)</p> <h2 id="demo-2d-linear-transformations"><a href="#demo-2d-linear-transformations" class="header-anchor">#</a> [Demo] 2D Linear Transformations</h2> <ul><li><a href="https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php" target="_blank" rel="noopener noreferrer">https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>행렬 요소의 값을 바꿔보세요</li> <li>다양한 변환 버튼을 눌러보세요</li></ul> <h2 id="quiz-1"><a href="#quiz-1" class="header-anchor">#</a> Quiz 1</h2> <h2 id="_2d-translation"><a href="#_2d-translation" class="header-anchor">#</a> 2D Translation</h2> <ul><li><p>Translation은 가장 간단한 변환:<br>
$T(\mathbf{v}) = \mathbf{v} + \mathbf{u}$</p></li> <li><p>역변환(Inverse):<br>
$T^{-1}(\mathbf{v}) = \mathbf{v} − \mathbf{u}$</p></li></ul> <p>(도식: $\mathbf{v}$ 벡터에서 $\mathbf{u}$만큼 이동한 결과가 $T(\mathbf{v})$)</p> <h2 id="is-translation-linear-transformation"><a href="#is-translation-linear-transformation" class="header-anchor">#</a> Is translation linear transformation?</h2> <ul><li><p><strong>아니오. 선형 변환(linear transformation)이 아님</strong></p></li> <li><p>선형성(linearity)을 만족하지 않음:<br>
$$
T(\mathbf{v}_1 + \mathbf{v}_2) \neq T(\mathbf{v}_1) + T(\mathbf{v}_2) \\ T(c\mathbf{v}) \neq cT(\mathbf{v})
$$</p> <p>예:</p> <p>$$
cT(\mathbf{v}) = c(\mathbf{v} + \mathbf{b}) = c\mathbf{v} + c\mathbf{b} \\ \neq T(c\mathbf{v}) = c\mathbf{v} + \mathbf{b}
$$</p></li> <li><p>벡터 덧셈을 사용해 표현 가능:<br>
$$ T(\mathbf{v}) = \mathbf{v} + \mathbf{u} $$</p></li> <li><p>선형 변환과 결합할 수 있음:<br>
$$ T(\mathbf{v}) = M\mathbf{v} + \mathbf{u} $$</p></li> <li><p>→ <strong>Affine transformation</strong></p></li></ul> <h2 id="let-s-check-again"><a href="#let-s-check-again" class="header-anchor">#</a> Let’s check again</h2> <ul><li><p><strong>Linear transformation</strong></p> <ul><li>Scaling, Rotation, Reflection, Shearing</li> <li>행렬 곱셈으로 표현 가능<br>
$$ T(\mathbf{v}) = M\mathbf{v} $$</li></ul></li> <li><p><strong>Translation</strong></p> <ul><li>선형 변환이 아님</li> <li>벡터 덧셈으로 표현됨<br>
$$ T(\mathbf{v}) = \mathbf{v} + \mathbf{u} $$</li></ul></li> <li><p><strong>Affine transformation</strong></p> <ul><li>선형 변환과 translation을 결합한 형태<br>
$$ T(\mathbf{v}) = M\mathbf{v} + \mathbf{u} $$</li></ul></li></ul> <h2 id="rigid-transformations"><a href="#rigid-transformations" class="header-anchor">#</a> Rigid Transformations</h2> <ul><li><p>모든 점 사이의 거리를 유지함</p> <p>$$
|g(\mathbf{u}) - g(\mathbf{v})| = |\mathbf{u} - \mathbf{v}|, \\ \forall \mathbf{u}, \mathbf{v} \in \mathbb{R}^3 \quad (g: \text{rigid transform map})
$$</p></li> <li><p>&quot;Handedness&quot;를 보존함:</p> <ul><li>선형 변환 중 handedness를 보존하는 회전의 조건:<br>
$$
g(\mathbf{u}) \times g(\mathbf{v}) = g(\mathbf{u} \times \mathbf{v}), \\ \forall \mathbf{u}, \mathbf{v} \in \mathbb{R}^3
$$
<ul><li>Reflection은 보존하지 않음</li></ul></li> <li>Translation은 방향을 바꾸지 않으므로 영향을 주지 않음</li></ul></li> <li><p>Rigid transformation의 예:</p> <ul><li>Translation</li> <li>Identity</li> <li>Rotation</li></ul></li> <li><p>일부 문헌에서는 reflection을 rigid로 분류하기도 하나, 본 강의에서는 포함하지 않음</p></li></ul> <h2 id="similarity-transformations"><a href="#similarity-transformations" class="header-anchor">#</a> Similarity Transformations</h2> <ul><li><p>각도를 보존함</p></li> <li><p>(rigid transformation도 각도 보존 포함)</p></li> <li><p>Similarity transformation의 예:</p> <ul><li>Translation</li> <li>Identity</li> <li>Rotation</li> <li><strong>Uniform Scaling</strong></li></ul></li> <li><p>일부 문헌에서는 reflection도 포함하나, 본 강의에서는 다루지 않음</p></li></ul> <h2 id="linear-transformations"><a href="#linear-transformations" class="header-anchor">#</a> Linear Transformations</h2> <ul><li><p>원점을 보존함</p></li> <li><p>포함되는 변환들:</p> <ul><li>Translation</li> <li>Identity</li> <li>Rotation</li> <li>Uniform Scaling</li> <li>Scaling</li> <li>Reflection</li> <li>Shearing</li></ul></li></ul> <h2 id="affine-transformations"><a href="#affine-transformations" class="header-anchor">#</a> Affine Transformations</h2> <ul><li>평행선을 유지함</li> <li>직선 상의 거리 비율을 유지함</li></ul> <h2 id="projective-transformations"><a href="#projective-transformations" class="header-anchor">#</a> Projective Transformations</h2> <ul><li>직선을 보존함
<img src="https://kmbzn.com/images/transformations.png" alt="transformations"></li></ul> <h2 id="composition-of-transformations"><a href="#composition-of-transformations" class="header-anchor">#</a> Composition of Transformations</h2> <ul><li><p>어떤 물체에 T 변환을 적용한 후, S 변환을 추가 적용:</p> <p>$$
\mathbf{p} \rightarrow T(\mathbf{p}) \rightarrow S(T(\mathbf{p})) = (S \circ T)(\mathbf{p})
$$</p></li> <li><p>2D linear transformation의 합성은<br>
2×2 행렬 곱셈으로 표현 가능:</p> <p>$$
T(\mathbf{p}) = M_T \mathbf{p}; \quad S(\mathbf{p}) = M_S \mathbf{p}
$$</p> <p>$$
(S \circ T)(\mathbf{p}) = M_S M_T \mathbf{p} \\
= (M_S M_T)\mathbf{p} = M_S (M_T \mathbf{p})
$$</p></li></ul> <h2 id="order-matters"><a href="#order-matters" class="header-anchor">#</a> Order Matters!</h2> <ul><li><p>행렬 곱셈은 결합법칙은 성립하지만 <strong>교환법칙은 성립하지 않음</strong>:</p> <p>$$
(AB)C = A(BC) \\
AB \ne BA
$$</p></li> <li><p>따라서, <strong>변환의 적용 순서가 매우 중요함</strong></p></li></ul> <p>(예: Scale → Rotate vs Rotate → Scale 결과가 다름)</p> <h2 id="demo-composition-of-linear-transformations"><a href="#demo-composition-of-linear-transformations" class="header-anchor">#</a> [Demo] Composition of Linear Transformations</h2> <ul><li><p><a href="https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php" target="_blank" rel="noopener noreferrer">https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>identity matrix로 초기화 (1 0 0 1 입력)</p></li> <li><p>&quot;Compose Transformations&quot; 버튼 클릭</p></li> <li><p>두 개의 변환을 서로 다른 순서로 적용해보기</p></li></ul> <h2 id="problems-when-handling-translation-as-vector-addition"><a href="#problems-when-handling-translation-as-vector-addition" class="header-anchor">#</a> Problems when handling Translation as Vector Addition</h2> <ul><li><p>선형 변환(회전, 스케일 등)과 translation을<br> <strong>일관된 방식으로 표현할 수 없음</strong></p></li> <li><p>Affine 변환의 합성은 복잡해짐:</p></li></ul> <p>$$
T(\mathbf{p}) = M_T \mathbf{p} + \mathbf{u}_T \\
S(\mathbf{p}) = M_S \mathbf{p} + \mathbf{u}_S
$$</p> <p>$$
(S \circ T)(\mathbf{p}) = M_S(M_T \mathbf{p} + \mathbf{u}_T) + \mathbf{u}_S \\
= (M_S M_T) \mathbf{p} + (M_S \mathbf{u}_T + \mathbf{u}_S)
$$</p> <ul><li>더 깔끔한 표현 방식이 필요함<br>
→ <strong>Homogeneous coordinates</strong></li></ul> <h2 id="homogeneous-coordinates"><a href="#homogeneous-coordinates" class="header-anchor">#</a> Homogeneous Coordinates</h2> <ul><li><p>핵심 아이디어: 2D 점을 3D 좌표계 상에 표현</p></li> <li><p>벡터에는 추가 성분($w$), 행렬에는 추가 행/열을 추가</p> <ul><li>점에는 항상 $w = 1$</li> <li>2D 점 $[x,~y]^T → [x,~y,~1]^T$</li></ul></li> <li><p>2D linear transformation의 표현:</p> <p>$$
\begin{bmatrix}
a &amp; b &amp; 0 \\
c &amp; d &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix} =
\begin{bmatrix}
ax + by \\
cx + dy \\
1
\end{bmatrix}
$$</p></li> <li><p>2D translation의 표현:</p> <p>$$
\begin{bmatrix}
1 &amp; 0 &amp; t \\
0 &amp; 1 &amp; s \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix} =
\begin{bmatrix}
x + t \\
y + s \\
1
\end{bmatrix}
$$</p></li> <li><p>2D affine transformation의 표현:</p> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; u_x \\
m_{21} &amp; m_{22} &amp; u_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p></li> <li><p><strong>Affine transformation 합성</strong>은 <strong>3×3 행렬 곱셈</strong>으로 간단하게 처리 가능:</p></li></ul> <p>$$
T(\mathbf{p}) = M_T \mathbf{p} + \mathbf{u}_T \\
S(\mathbf{p}) = M_S \mathbf{p} + \mathbf{u}_S
$$</p> <p>→ block 행렬 표현:</p> <p>$$
T(\mathbf{p}) =
\begin{bmatrix}
M_T &amp; \mathbf{u}_T \\
0 &amp; 1
\end{bmatrix}, \\
S(\mathbf{p}) =
\begin{bmatrix}
M_S &amp; \mathbf{u}_S \\
0 &amp; 1
\end{bmatrix}
$$</p> <p>$$
(S \circ T)(\mathbf{p}) \\ =
\begin{bmatrix}
M_S &amp; \mathbf{u}_S \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
M_T &amp; \mathbf{u}_T \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
\mathbf{p} \\
1
\end{bmatrix} \\ =
\begin{bmatrix}
(M_S M_T) \mathbf{p} + (M_S \mathbf{u}_T + \mathbf{u}_S) \\
1
\end{bmatrix}
$$</p> <ul><li>결과는 이전 방식과 같지만, <strong>훨씬 간단하고 깔끔함</strong></li></ul> <blockquote><p>cf. 기존 표현과 비교:<br>
$(S \circ T)(\mathbf{p}) = M_S(M_T \mathbf{p} + \mathbf{u}_T) + \mathbf{u}_S$<br>
$= (M_S M_T)\mathbf{p} + (M_S \mathbf{u}_T + \mathbf{u}_S)$</p></blockquote> <h2 id="demo-composition-of-affine-transformations-in-homogeneous-coordinates"><a href="#demo-composition-of-affine-transformations-in-homogeneous-coordinates" class="header-anchor">#</a> [Demo] Composition of Affine Transformations in Homogeneous Coordinates</h2> <ul><li><p><a href="https://observablehq.com/@esperanc/transformation-demo" target="_blank" rel="noopener noreferrer">https://observablehq.com/@esperanc/transformation-demo<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>‘+’ 버튼으로 다양한 순서의 translation 및 linear transformation 추가</p></li> <li><p>슬라이더로 행렬 값의 변화와 도형 변형 확인</p></li> <li><p>주의: 마지막에 추가된 변환이 <strong>가장 먼저 적용</strong>됨</p></li></ul> <h2 id="summary-homogeneous-coordinates-in-2d"><a href="#summary-homogeneous-coordinates-in-2d" class="header-anchor">#</a> Summary: Homogeneous Coordinates in 2D</h2> <ul><li>2D 점에는 $(x,~y)^T$ 대신 $(x,~y,~1)^T$ 사용</li> <li>2D linear transformation에는 2×2 행렬 대신 <strong>3×3 행렬</strong> 사용</li> <li>2D translation에도 벡터 덧셈 대신 <strong>3×3 행렬</strong> 사용</li></ul> <p>→ linear transformation과 translation을 <strong>일관된 방식으로 처리할 수 있음!</strong></p> <h2 id="quiz-2"><a href="#quiz-2" class="header-anchor">#</a> Quiz 2</h2> <h2 id="now-let-s-go-to-the-3d-world"><a href="#now-let-s-go-to-the-3d-world" class="header-anchor">#</a> Now, Let’s go to the 3D world!</h2> <ul><li>Coordinate system (좌표계)
<ul><li>Cartesian coordinate system (직교좌표계)
<ul><li>2D 좌표계 → z축이 포함된 3D 좌표계로 확장됨</li></ul></li></ul></li></ul> <h2 id="right-handed-and-left-handed-coordinate-systems"><a href="#right-handed-and-left-handed-coordinate-systems" class="header-anchor">#</a> Right-Handed and Left-Handed Coordinate Systems</h2> <ul><li>우리가 사용하는 시스템: <strong>Right-handed Cartesian Coordinates</strong></li></ul> <table><thead><tr><th>항목</th> <th>Right-handed</th> <th>Left-handed</th></tr></thead> <tbody><tr><td>회전 방향</td> <td>축 기준 반시계 방향</td> <td>축 기준 시계 방향</td></tr> <tr><td>사용 예시</td> <td><strong>OpenGL</strong>, Maya, Houdini, AutoCAD, Physics &amp; Math</td> <td>DirectX, Unity, Unreal 등</td></tr></tbody></table> <p>(이미지: 오른손 법칙과 왼손 법칙 설명)</p> <h2 id="point-representations-in-cartesian-homogeneous-coordinate-system"><a href="#point-representations-in-cartesian-homogeneous-coordinate-system" class="header-anchor">#</a> Point Representations in Cartesian &amp; Homogeneous Coordinate System</h2> <h3 id="a-2d-point-is-represented-as"><a href="#a-2d-point-is-represented-as" class="header-anchor">#</a> A 2D point is represented as:</h3> <ul><li><p><strong>Cartesian coordinate system</strong>:
$$
\begin{bmatrix}
p_x \\
p_y
\end{bmatrix}
$$</p></li> <li><p><strong>Homogeneous coordinate system</strong>:
$$
\begin{bmatrix}
p_x \\
p_y \\
1
\end{bmatrix}
$$</p></li></ul> <hr> <h3 id="a-3d-point-is-represented-as"><a href="#a-3d-point-is-represented-as" class="header-anchor">#</a> A 3D point is represented as:</h3> <ul><li><p><strong>Cartesian coordinate system</strong>:
$$
\begin{bmatrix}
p_x \\
p_y \\
p_z
\end{bmatrix}
$$</p></li> <li><p><strong>Homogeneous coordinate system</strong>:
$$
\begin{bmatrix}
p_x \\
p_y \\
p_z \\
1
\end{bmatrix}
$$</p></li></ul> <h2 id="review-of-linear-transformations-in-2d"><a href="#review-of-linear-transformations-in-2d" class="header-anchor">#</a> Review of Linear Transformations in 2D</h2> <ul><li>2D에서의 선형 변환은 다음과 같은 행렬 곱셈으로 표현됨:</li></ul> <h3 id="_2x2-matrix-in-cartesian-coordinates"><a href="#_2x2-matrix-in-cartesian-coordinates" class="header-anchor">#</a> 2x2 matrix (in Cartesian coordinates):</h3> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} \\
m_{21} &amp; m_{22}
\end{bmatrix}
\begin{bmatrix}
p_x \\
p_y
\end{bmatrix}
$$</p> <h3 id="or"><a href="#or" class="header-anchor">#</a> or</h3> <h3 id="_3x3-matrix-in-homogeneous-coordinates"><a href="#_3x3-matrix-in-homogeneous-coordinates" class="header-anchor">#</a> 3x3 matrix (in homogeneous coordinates):</h3> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; 0 \\
m_{21} &amp; m_{22} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
p_x \\
p_y \\
1
\end{bmatrix}
$$</p> <h2 id="linear-transformations-in-3d"><a href="#linear-transformations-in-3d" class="header-anchor">#</a> Linear Transformations in 3D</h2> <ul><li><p>3D에서의 선형 변환은 다음 행렬 곱셈으로 표현됨:</p> <p>3x3 matrix (in Cartesian coordinates)<br>
또는<br>
4x4 matrix (in homogeneous coordinates)</p> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; m_{13} \\
m_{21} &amp; m_{22} &amp; m_{23} \\
m_{31} &amp; m_{32} &amp; m_{33}
\end{bmatrix}
\begin{bmatrix}
p_x \\
p_y \\
p_z
\end{bmatrix}
\\ \text{or}\ \\
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; m_{13} &amp; 0 \\
m_{21} &amp; m_{22} &amp; m_{23} &amp; 0 \\
m_{31} &amp; m_{32} &amp; m_{33} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
p_x \\
p_y \\
p_z \\
1
\end{bmatrix}
$$</p></li></ul> <h2 id="linear-transformations-in-3d-2"><a href="#linear-transformations-in-3d-2" class="header-anchor">#</a> Linear Transformations in 3D</h2> <p><strong>Scaling (크기 조절):</strong></p> <p>$$
S_s =
\begin{bmatrix}
S_x &amp; 0 &amp; 0 \\
0 &amp; S_y &amp; 0 \\
0 &amp; 0 &amp; S_z
\end{bmatrix}
\quad\text{(3D)}
\\
S_s =
\begin{bmatrix}
S_x &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; S_y &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; S_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\quad\text{(3D-H)}
$$</p> <p><strong>Shear (in $x$, based on $z$ position):</strong></p> <p>$$
H_{x,d} =
\begin{bmatrix}
1 &amp; d_y &amp; d_z \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\\ \text{or} \\
H_{x,d} =
\begin{bmatrix}
1 &amp; d_y &amp; d_z &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p> <h2 id="linear-transformations-in-3d-3"><a href="#linear-transformations-in-3d-3" class="header-anchor">#</a> Linear Transformations in 3D</h2> <p><strong>Rotation about $x$-axis:</strong></p> <p>$$
R_{x,\theta} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos\theta &amp; -\sin\theta \\
0 &amp; \sin\theta &amp; \cos\theta
\end{bmatrix}
$$</p> <p><strong>Rotation about $y$-axis:</strong></p> <p>$$
R_{y,\theta} =
\begin{bmatrix}
\cos\theta &amp; 0 &amp; \sin\theta \\
0 &amp; 1 &amp; 0 \\
-\sin\theta &amp; 0 &amp; \cos\theta
\end{bmatrix}
$$</p> <p><strong>Rotation about $z$-axis:</strong></p> <p>$$
R_{z,\theta} =
\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p> <p>(오른손 법칙에 따라 z축을 기준으로 위에서 아래로 보는 시점에서 반시계 방향 회전)</p> <h2 id="review-of-translations-in-2d"><a href="#review-of-translations-in-2d" class="header-anchor">#</a> Review of Translations in 2D</h2> <ul><li>2D에서의 Translation은 다음 두 방식으로 표현 가능:</li></ul> <p><strong>Vector addition</strong> <em>(in Cartesian coordinates)</em>:</p> <p>$$
\begin{bmatrix}
p_x \\ p_y
\end{bmatrix}
+
\begin{bmatrix}
u_x \\ u_y
\end{bmatrix}
$$</p> <p><strong>Matrix multiplication</strong> <em>(in homogeneous coordinates)</em>:</p> <p>$$
\begin{bmatrix}
1 &amp; 0 &amp; u_x \\
0 &amp; 1 &amp; u_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
p_x \\ p_y \\ 1
\end{bmatrix}
$$</p> <h2 id="translations-in-3d"><a href="#translations-in-3d" class="header-anchor">#</a> Translations in 3D</h2> <ul><li>3D에서의 Translation도 유사하게 표현 가능:</li></ul> <p><strong>Vector addition (Cartesian coordinates):</strong></p> <p>$$
\begin{bmatrix}
p_x \\ p_y \\ p_z
\end{bmatrix}
+
\begin{bmatrix}
u_x \\ u_y \\ u_z
\end{bmatrix}
$$</p> <p><strong>Matrix multiplication (homogeneous coordinates):</strong></p> <p>$$
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; u_x \\
0 &amp; 1 &amp; 0 &amp; u_y \\
0 &amp; 0 &amp; 1 &amp; u_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
p_x \\ p_y \\ p_z \\ 1
\end{bmatrix}
$$</p> <h2 id="review-of-affine-transformations-in-2d"><a href="#review-of-affine-transformations-in-2d" class="header-anchor">#</a> Review of Affine Transformations in 2D</h2> <ul><li>Homogeneous coordinates에서는 2D affine transformation을 3×3 행렬 곱으로 표현할 수 있음:</li></ul> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; u_x \\
m_{21} &amp; m_{22} &amp; u_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p> <h2 id="affine-transformations-in-3d"><a href="#affine-transformations-in-3d" class="header-anchor">#</a> Affine Transformations in 3D</h2> <ul><li>Homogeneous coordinates에서는 3D affine transformation을<br>
4×4 행렬 곱으로 표현할 수 있음:</li></ul> <p>$$
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; m_{13} &amp; u_x \\
m_{21} &amp; m_{22} &amp; m_{23} &amp; u_y \\
m_{31} &amp; m_{32} &amp; m_{33} &amp; u_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p> <h2 id="summary-affine-transformation"><a href="#summary-affine-transformation" class="header-anchor">#</a> Summary: Affine Transformation</h2> <ul><li>$\mathbf{p}$라는 점 집합에 대해 affine transformation $\mathbf{M}$을 적용하면:
$$
\mathbf{M} =
\begin{bmatrix}
m_{11} &amp; m_{12} &amp; m_{13} &amp; u_1 \\
m_{21} &amp; m_{22} &amp; m_{23} &amp; u_2 \\
m_{31} &amp; m_{32} &amp; m_{33} &amp; u_3 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</li></ul> <p>$$
\mathbf{p}_i' \leftarrow \mathbf{M} \mathbf{p}_i
$$</p> <p>$$
\mathbf{p}_1' \leftarrow \mathbf{M} \mathbf{p}_1 \\
\mathbf{p}_2' \leftarrow \mathbf{M} \mathbf{p}_2 \\
\mathbf{p}_3' \leftarrow \mathbf{M} \mathbf{p}_3 \\ \dots \\
\mathbf{p}_N' \leftarrow \mathbf{M} \mathbf{p}_N
$$</p> <h2 id="summary-composition-of-affine-transformations"><a href="#summary-composition-of-affine-transformations" class="header-anchor">#</a> Summary: Composition of Affine Transformations</h2> <ul><li><p>여러 개의 affine transformation (예: M₁, M₂)을 순차적으로 적용할 수 있음</p></li> <li><p>각 점마다 개별적으로:</p></li></ul> <p>$$
\mathbf{p}_i'' \leftarrow \mathbf{M}_2  \mathbf{M}_1  \mathbf{p}_i
$$</p> <p>$$
\mathbf{p}_1'' \leftarrow \mathbf{M}_2 \mathbf{M}_1 \mathbf{p}_1 \\
\mathbf{p}_2'' \leftarrow \mathbf{M}_2 \mathbf{M}_1 \mathbf{p}_2 \\
\mathbf{p}_3'' \leftarrow \mathbf{M}_2 \mathbf{M}_1 \mathbf{p}_3 \\ \dots \\
\mathbf{p}_N'' \leftarrow \mathbf{M}_2 \mathbf{M}_1 \mathbf{p}_N
$$</p> <div class="theme-default-content content__default"><div class="footer"><hr> <p class="built-with">BUILT WITH</p> <div class="tech-logos"><a href="https://www.cloudflare.com/" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cloudflare/cloudflare-original.svg" alt="Cloudflare"></a> <a href="https://nodejs.org/" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/nodejs/nodejs-original.svg" alt="Node.js"></a> <a href="https://github.com/kmbzn" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="GitHub"></a> <a href="https://git-scm.com/" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="Git"></a> <a href="https://vuejs.org/" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vuejs/vuejs-original.svg" alt="Vue.js"></a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" alt="JavaScript"></a> <a href="https://code.visualstudio.com/" target="_blank"><img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="VSCode"></a> <a href="https://openai.com/chatgpt" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/ChatGPT-Logo.svg/120px-ChatGPT-Logo.svg.png" alt="ChatGPT"></a> <a href="https://katex.org/" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/KaTeX_logo.svg/250px-KaTeX_logo.svg.png" alt="KaTeX"></a></div> <p class="copyright">
      All trademarks and logos are property of their respective owners.<br>
      © 2025 <strong>kmbzn</strong> · <a href="https://github.com/kmbzn/blog/blob/master/LICENSE" target="_blank">MIT License</a><br>
      Based on © 2020 <strong>Gyoogle</strong> · <a href="https://github.com/gyoogle/blog/blob/master/LICENSE" target="_blank">MIT License</a></p></div></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/computer-graphics/2-Rendering-Basics.html" class="prev">
        2-Rendering-Basics
      </a></span> <span class="next"><a href="/computer-graphics/4-Affine-Space-Frame_Matrix.html">
        4-Affine-Space-Frame_Matrix
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.4280e306.js" defer></script><script src="/assets/js/18.bb8e1e7a.js" defer></script><script src="/assets/js/2.a3ccddde.js" defer></script><script src="/assets/js/1.93e900e1.js" defer></script><script src="/assets/js/29.4d7b2591.js" defer></script><script src="/assets/js/20.9f752867.js" defer></script><script src="/assets/js/22.6bbde796.js" defer></script>
  </body>
</html>

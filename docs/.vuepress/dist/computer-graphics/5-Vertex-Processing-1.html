<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>5 - Vertex Processing 1</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="/images/android-chrome-512x512.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/victor-mono@latest/dist/index.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretendard@1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.css">
    <meta name="description" content="Summarizing key concepts from CS lectures.">
    <meta property="og:description" content="by kmbzn">
    <meta property="og:image" content="https://kmbzn.com/images/og-home.png">
    
    <link rel="preload" href="/assets/css/0.styles.6393867d.css" as="style"><link rel="preload" href="/assets/js/app.3f9354f2.js" as="script"><link rel="preload" href="/assets/js/18.bb8e1e7a.js" as="script"><link rel="preload" href="/assets/js/2.a3ccddde.js" as="script"><link rel="preload" href="/assets/js/1.93e900e1.js" as="script"><link rel="preload" href="/assets/js/31.3f4b63f6.js" as="script"><link rel="preload" href="/assets/js/22.6bbde796.js" as="script"><link rel="prefetch" href="/assets/js/10.6637bfee.js"><link rel="prefetch" href="/assets/js/11.89241896.js"><link rel="prefetch" href="/assets/js/12.1f81aafc.js"><link rel="prefetch" href="/assets/js/13.db5eb42a.js"><link rel="prefetch" href="/assets/js/14.a654c061.js"><link rel="prefetch" href="/assets/js/15.82f66eb5.js"><link rel="prefetch" href="/assets/js/16.41334cbf.js"><link rel="prefetch" href="/assets/js/17.9f4ed163.js"><link rel="prefetch" href="/assets/js/19.6965bf28.js"><link rel="prefetch" href="/assets/js/20.1bb4a017.js"><link rel="prefetch" href="/assets/js/21.85cd1bb2.js"><link rel="prefetch" href="/assets/js/23.1c6b188d.js"><link rel="prefetch" href="/assets/js/24.bffcbf0e.js"><link rel="prefetch" href="/assets/js/25.bf3894f9.js"><link rel="prefetch" href="/assets/js/26.be62c9f8.js"><link rel="prefetch" href="/assets/js/27.8173b92d.js"><link rel="prefetch" href="/assets/js/28.eef9d038.js"><link rel="prefetch" href="/assets/js/29.b47ece12.js"><link rel="prefetch" href="/assets/js/3.7e2f5075.js"><link rel="prefetch" href="/assets/js/30.1b08b666.js"><link rel="prefetch" href="/assets/js/32.ad33d72d.js"><link rel="prefetch" href="/assets/js/33.d491e2e6.js"><link rel="prefetch" href="/assets/js/34.9fade83f.js"><link rel="prefetch" href="/assets/js/35.646e59d5.js"><link rel="prefetch" href="/assets/js/4.107563ed.js"><link rel="prefetch" href="/assets/js/5.5467bfa0.js"><link rel="prefetch" href="/assets/js/6.e9ea9ee0.js"><link rel="prefetch" href="/assets/js/7.4a5373f5.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.663d6e13.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6393867d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/kmbzn.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>🖥️ Computer Graphics</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/computer-graphics/1-Course-Intro.html" class="sidebar-link">1-Course-Intro</a></li><li><a href="/computer-graphics/2-Rendering-Basics.html" class="sidebar-link">2-Rendering-Basics</a></li><li><a href="/computer-graphics/3-Transformations-v2.html" class="sidebar-link">3-Transformations-v2</a></li><li><a href="/computer-graphics/4-Affine-Space-Frame_Matrix.html" class="sidebar-link">4-Affine-Space-Frame_Matrix</a></li><li><a href="/computer-graphics/5-Vertex-Processing-1.html" aria-current="page" class="active sidebar-link">5-Vertex-Processing-1</a></li><li><a href="/computer-graphics/6-Vertex-Processing-2.html" class="sidebar-link">6-Vertex-Processing-2</a></li><li><a href="/computer-graphics/7-Hierachical-Modeling-Mesh.html" class="sidebar-link">7-Hierachical-Modeling-Mesh</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_5-vertex-processing-1"><a href="#_5-vertex-processing-1" class="header-anchor">#</a> 5 - Vertex Processing 1</h1> <h2 id="outline"><a href="#outline" class="header-anchor">#</a> Outline</h2> <ul><li>Rasterization Pipeline &amp; Vertex Processing</li> <li>Modeling Transformation</li> <li>Viewing Transformation</li></ul> <h2 id="rasterization-pipeline-vertex-processing"><a href="#rasterization-pipeline-vertex-processing" class="header-anchor">#</a> Rasterization Pipeline &amp; Vertex Processing</h2> <h2 id="recall-rasterization-pipeline"><a href="#recall-rasterization-pipeline" class="header-anchor">#</a> Recall: Rasterization Pipeline</h2> <ul><li>Vertex Processing
<ul><li>정점(vertex)을 화면 좌표(screen space)로 변환</li></ul></li> <li>Primitive Processing
<ul><li>정점들을 모아 polygon 구성</li></ul></li> <li>Scan Conversion
<ul><li>polygon을 fragment로 변환</li></ul></li> <li>Fragment Processing
<ul><li>조명 및 텍스처에 따라 각 fragment의 색 결정</li></ul></li> <li>Per-sample Operations
<ul><li>depth test, alpha blending 등 수행</li></ul></li></ul> <h2 id="recall-rasterization-pipeline-2"><a href="#recall-rasterization-pipeline-2" class="header-anchor">#</a> Recall: Rasterization Pipeline</h2> <ul><li><p>Vertex Processing:</p> <ul><li>정점들을 화면 좌표계로 변환</li> <li>일련의 정점 변환 시퀀스를 적용</li></ul></li> <li><p>우리가 지금까지 학습한 범위는 →</p> <ul><li>Primitive Processing ~ Per-sample Operations</li></ul></li> <li><p>오늘과 다음 시간에 볼 내용 →</p> <ul><li><strong>Vertex Processing</strong></li></ul></li></ul> <h2 id="vertex-processing"><a href="#vertex-processing" class="header-anchor">#</a> Vertex Processing</h2> <ul><li><p>각 객체의 body frame에서의 정점 위치:</p> <div class="language- extra-class"><pre class="language-text"><code>P₁, P₂, P₃
</code></pre></div></li> <li><p>World frame으로의 변환:</p> <div class="language- extra-class"><pre class="language-text"><code>M * P₁, M * P₂, M * P₃
</code></pre></div></li> <li><p>→ 하지만 아직 화면에 표시하기 위해선 추가 개념이 필요함</p> <p><strong>“카메라”가 장면을 바라본다는 개념 도입 필요</strong></p></li> <li><p>이어지는 단계:</p> <ol start="2"><li>“카메라” 배치</li> <li>“렌즈” 선택</li> <li>“스크린”에 투사</li></ol></li></ul> <h2 id="in-terms-of-cg-transformation"><a href="#in-terms-of-cg-transformation" class="header-anchor">#</a> In Terms of CG Transformation,</h2> <ol><li><p>객체 배치<br>
→ <strong>Modeling Transformation</strong></p></li> <li><p>카메라 배치<br>
→ <strong>Viewing Transformation</strong></p></li> <li><p>렌즈 선택<br>
→ <strong>Projection Transformation</strong></p></li> <li><p>화면에 출력<br>
→ <strong>Viewport Transformation</strong></p></li></ol> <ul><li>위 모든 변환은 <strong>행렬 곱셈</strong>으로 구성됨</li></ul> <h2 id="vertex-processing-transformation-pipeline"><a href="#vertex-processing-transformation-pipeline" class="header-anchor">#</a> Vertex Processing (Transformation Pipeline)</h2> <ul><li><p>Object space (body frame):</p> <ul><li>객체 기준 좌표계</li></ul></li> <li><p>World space (world frame):</p> <ul><li>전체 장면 기준 좌표계</li></ul></li> <li><p>수행할 작업:</p> <ul><li>이동(translate), 회전(rotate), 크기 조절(scale) 등</li> <li>이전 강의에서 다룬 모든 affine 변환 포함</li></ul></li></ul> <hr> <p><strong>Modeling transformation</strong></p> <ul><li>객체 좌표계 (object space) → world 좌표계로 변환</li> <li>이전 강의에서 배운 affine transformation을 적용함</li></ul> <hr> <p><strong>Placing a “camera”</strong></p> <ul><li>world 좌표계 상에서 카메라를 배치함</li> <li>view space (또는 camera space) 정의됨</li></ul> <hr> <p><strong>Viewing transformation</strong></p> <ul><li>world space → camera space로 변환</li> <li>즉, world 기준 장면을 카메라 기준으로 재배열</li></ul> <hr> <p><strong>Selecting its “lens”</strong></p> <ul><li>투영 방식을 정의함 (예: perspective, orthographic 등)</li> <li>view space → <strong>Clip space / NDC (normalized device coordinate) space</strong></li></ul> <hr> <p><strong>Projection transformation</strong></p> <ul><li>시야각(FOV), 종횡비, near/far plane 등을 고려하여<br>
3D 공간을 <strong>정규화된 장치 좌표계(NDC)</strong> 로 변환</li> <li>좌표 범위: (-1, -1, -1) ~ (1, 1, 1)</li></ul> <hr> <p><strong>Displaying on a “cinema screen”</strong></p> <ul><li>NDC 공간을 이미지 공간으로 변환</li> <li>즉, 픽셀 좌표계 상에 화면 출력</li></ul> <hr> <p><strong>Viewport transformation</strong></p> <ul><li>NDC 좌표를 실제 화면 해상도에 맞게 스케일 조정</li> <li>좌표계를 정규화 공간 → 스크린 공간으로 변환</li></ul> <hr> <p><strong>Transformation Pipeline 전체 요약</strong></p> <p>Object space → View space → Clip space → Screen space</p> <ol><li><strong>Modeling transformation</strong></li> <li><strong>Viewing transformation</strong></li> <li><strong>Projection transformation</strong></li> <li><strong>Viewport transformation</strong></li></ol> <p>→ 모든 과정은 <strong>행렬 곱(Matrix Multiplication)</strong> 으로 구성됨</p> <hr> <ul><li>Modeling, Viewing, Projection, Viewport 변환은<br> <strong>4x4 행렬 곱셈</strong>으로 처리됨</li></ul> <hr> <p><strong>MVP Matrix 적용</strong></p> <ul><li><p>하나의 점 $begin:math:text$ \mathbf{p}_o $end:math:text$가</p> <ul><li>모델링 변환: $begin:math:text$ M $end:math:text$</li> <li>뷰잉 변환: $begin:math:text$ V $end:math:text$</li> <li>투영 변환: $begin:math:text$ P $end:math:text$</li> <li>뷰포트 변환: $begin:math:text$ T_{vp} $end:math:text$<br>
을 거쳐서</li> <li>최종 위치 $begin:math:text$ \mathbf{p}_s $end:math:text$로 변환됨</li></ul> <div class="language- extra-class"><pre class="language-text"><code>p_s = T_vp * P * V * M * p_o
</code></pre></div></li></ul> <hr> <h1 id="modeling-transformation"><a href="#modeling-transformation" class="header-anchor">#</a> Modeling Transformation</h1> <h2 id="modeling-transformation-2"><a href="#modeling-transformation-2" class="header-anchor">#</a> Modeling Transformation</h2> <ul><li>object space에서 world space로의 변환<br>
$begin:math:text$ \mathbf{p}_w = M \mathbf{p}_o $end:math:text$</li> <li>이때 M은 affine transformation들의 조합</li> <li>예: 이동, 회전, 스케일 등</li></ul> <hr> <h2 id="recall-directions-of-the-arrow"><a href="#recall-directions-of-the-arrow" class="header-anchor">#</a> Recall: Directions of the &quot;arrow&quot;</h2> <ul><li>$begin:math:text$ \mathbf{p}_w = M \mathbf{p}^{(1)} $end:math:text$</li> <li>1번째 의미: geometry 변환 방향</li> <li>3번째 의미: frame이 바뀌는 관점에서 → 방향 반대가 되는 것처럼 보일 수 있음</li></ul> <hr> <h2 id="modeling-transformation-3"><a href="#modeling-transformation-3" class="header-anchor">#</a> Modeling Transformation</h2> <ul><li><p>객체는 <strong>object의 고유 좌표계(body frame)</strong> 에 정의됨</p></li> <li><p>object → world 변환을 <strong>modeling transformation</strong>이라 하며<br>
행렬 $begin:math:text$ M $end:math:text$로 표현됨</p></li> <li><p>이 행렬 $begin:math:text$ M $end:math:text$은 지금까지 배운 affine 변환(이동, 회전, 스케일 등)의 조합</p></li></ul> <hr> <p><strong>예시: 다중 부품의 modeling</strong></p> <ul><li>바퀴, 캐빈, 컨테이너 각각의 object frame에서
<ul><li>modeling matrix $begin:math:text$ M_{wheel}, M_{cab}, M_{container} $end:math:text$를 적용</li> <li>최종적으로 world frame 상의 전체 트럭 위치가 구성됨</li></ul></li></ul> <hr> <h2 id="quiz-1"><a href="#quiz-1" class="header-anchor">#</a> Quiz 1</h2> <h1 id="viewing-transformation"><a href="#viewing-transformation" class="header-anchor">#</a> Viewing Transformation</h1> <h2 id="viewing-transformation-2"><a href="#viewing-transformation-2" class="header-anchor">#</a> Viewing Transformation</h2> <ul><li>Viewing transformation은 <strong>world space</strong>에서 **camera space(view space)**로 변환하는 연산이다.</li> <li>변환된 결과는 결국 화면상의 2D 이미지(screen space)에 나타난다.</li> <li>이 과정은 다음과 같은 수식을 따른다:<div class="language- extra-class"><pre class="language-text"><code>pᵥ = V * p𝓌
</code></pre></div></li></ul> <h2 id="recall-that"><a href="#recall-that" class="header-anchor">#</a> Recall that...</h2> <ul><li><ol><li>객체 배치<br>
→ Modeling transformation</li></ol></li> <li><ol start="2"><li>&quot;카메라&quot; 배치<br>
→ Viewing transformation</li></ol></li> <li><ol start="3"><li>&quot;렌즈&quot; 선택<br>
→ Projection transformation</li></ol></li> <li><ol start="4"><li>&quot;스크린&quot;에 표시<br>
→ Viewport transformation</li></ol></li></ul> <h2 id="viewing-transformation-3"><a href="#viewing-transformation-3" class="header-anchor">#</a> Viewing Transformation</h2> <ul><li>Viewing transformation은 <strong>rigid transformation</strong>으로서, <strong>회전과 이동</strong>을 포함한다.</li> <li>world space에서 view space로 변환하는 데 사용되며, 변환 행렬은 <strong>viewing matrix V</strong>이다.</li></ul> <h2 id="viewing-transformation-4"><a href="#viewing-transformation-4" class="header-anchor">#</a> Viewing Transformation</h2> <ul><li>목적: <strong>camera frame</strong> 상에서 모든 객체의 vertex들을 표현하는 것</li> <li>이를 위해 <strong>camera frame</strong>을 정의해야 함 (world frame 기준)</li> <li>camera frame을 정의한다는 것은 곧 <strong>카메라의 위치와 방향</strong>을 결정하는 것과 같다.</li></ul> <h2 id="defining-camera-frame-1-lookat"><a href="#defining-camera-frame-1-lookat" class="header-anchor">#</a> Defining Camera Frame 1 - &quot;LookAt&quot;</h2> <ul><li>카메라의 위치와 방향을 정의하는 여러 방식이 있다.</li> <li>그 중 직관적인 방식으로 <strong>lookat 함수</strong>를 소개:
<ul><li><strong>Eye point</strong>: 카메라 위치</li> <li><strong>Look-at point</strong>: 카메라가 바라보는 지점</li> <li><strong>Up vector</strong>: 어느 방향이 위를 나타내는지 설명</li></ul></li></ul> <h2 id="demo-lookat-function"><a href="#demo-lookat-function" class="header-anchor">#</a> [Demo] LookAt Function</h2> <ul><li>https://learnwebgl.brown37.net/07_camera/camera_lookat/camera_lookat.html</li> <li>슬라이더를 움직이며 eye, center, up 값을 바꿔보면,</li> <li>3D 장면의 뷰가 어떻게 변하는지 관찰할 수 있다.</li></ul> <h2 id="defining-camera-frame-1-lookat-2"><a href="#defining-camera-frame-1-lookat-2" class="header-anchor">#</a> Defining Camera Frame 1 - &quot;LookAt&quot;</h2> <ul><li>eye point, look-at point, up vector가 주어지면, <strong>camera frame</strong>을 계산할 수 있다.</li> <li>카메라 좌표축으로는 일반적으로 <strong>u, v, w</strong> 벡터를 사용하며, 이는 각각 다음을 나타냄:
<ul><li><strong>u</strong>: 오른쪽 방향</li> <li><strong>v</strong>: 위쪽 방향</li> <li><strong>w</strong>: 뒤쪽 방향</li></ul></li> <li>camera frame을 정의하려면 <strong>u, v, w 벡터</strong>와 <strong>원점</strong>을 구해야 함</li></ul> <h2 id="given-eye-point-look-at-point-up-vector"><a href="#given-eye-point-look-at-point-up-vector" class="header-anchor">#</a> Given Eye point, Look-at point, Up vector</h2> <ul><li>Eye point, Look-at point, Up vector를 이용하여 카메라 좌표계를 정의한다.</li></ul> <h2 id="getting-origin-point"><a href="#getting-origin-point" class="header-anchor">#</a> Getting origin point</h2> <ul><li>Eye point 자체가 <strong>카메라 좌표계의 원점</strong>이 된다.<div class="language- extra-class"><pre class="language-text"><code>origin of camera frame = Eye point
</code></pre></div></li></ul> <h2 id="getting-w-axis-vector"><a href="#getting-w-axis-vector" class="header-anchor">#</a> Getting &quot;w&quot; axis vector</h2> <ul><li>Look-at point를 바라보는 방향을 w축으로 정의한다.<div class="language- extra-class"><pre class="language-text"><code>w = (P_eye - P_ref) / ||P_eye - P_ref||
</code></pre></div></li></ul> <h2 id="getting-u-axis-vector"><a href="#getting-u-axis-vector" class="header-anchor">#</a> Getting &quot;u&quot; axis vector</h2> <ul><li>up 방향 벡터와 w 벡터의 외적을 통해 u 축을 계산한다.<div class="language- extra-class"><pre class="language-text"><code>u = (V_up × w) / ||V_up × w||
</code></pre></div></li></ul> <h2 id="getting-v-axis-vector"><a href="#getting-v-axis-vector" class="header-anchor">#</a> Getting &quot;v&quot; axis vector</h2> <ul><li>직교좌표계를 만들기 위해 다음과 같이 정의한다.<div class="language- extra-class"><pre class="language-text"><code>v = w × u
</code></pre></div></li></ul> <h2 id="recall-2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"><a href="#recall-2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame" class="header-anchor">#</a> Recall: 2) Affine Transformation Matrix defines an Affine Frame w.r.t. World Frame</h2> <ul><li>Affine 변환 행렬 M은 좌표계(프레임)를 변환하는데 사용된다.</li> <li>프레임 {1}은 프레임 {0} 기준으로 정의된다.</li> <li>좌표계 축(x, y, z)과 원점 좌표가 행렬의 열(column)로 구성된다.</li></ul> <h2 id="thus-the-camera-frame-is-defined-by"><a href="#thus-the-camera-frame-is-defined-by" class="header-anchor">#</a> Thus, the Camera Frame is defined by</h2> <ul><li>camera frame의 변환 행렬 M은 다음과 같이 구성된다:<div class="language- extra-class"><pre class="language-text"><code>| u_x  v_x  w_x  P_eye_x |
| u_y  v_y  w_y  P_eye_y |
| u_z  v_z  w_z  P_eye_z |
|  0     0     0      1  |
</code></pre></div></li></ul> <h2 id="how-can-we-get-viewing-matrix-v-from-the-camera-frame"><a href="#how-can-we-get-viewing-matrix-v-from-the-camera-frame" class="header-anchor">#</a> How can we get viewing matrix V from the camera frame?</h2> <ul><li>모델링 변환의 방식과 유사하게 viewing matrix V를 구할 수 있다.</li> <li>기본적으로, 객체의 body frame에서의 좌표를 world frame으로 변환하는 affine matrix의 역행렬이 바로 viewing matrix가 된다.</li></ul> <h2 id="how-can-we-get-viewing-matrix-v-from-the-camera-frame-2"><a href="#how-can-we-get-viewing-matrix-v-from-the-camera-frame-2" class="header-anchor">#</a> How can we get viewing matrix V from the camera frame?</h2> <ul><li>객체 공간(Object space)을 카메라 공간(Camera space)으로 바꾸면, 어떤 변환 행렬이 필요할까?</li></ul> <h2 id="how-can-we-get-viewing-matrix-v-from-the-camera-frame-3"><a href="#how-can-we-get-viewing-matrix-v-from-the-camera-frame-3" class="header-anchor">#</a> How can we get viewing matrix V from the camera frame?</h2> <ul><li>뷰 공간(View space) → 월드 공간(World space) 방향으로 변환한다면?</li></ul> <h2 id="how-can-we-get-viewing-matrix-v-from-the-camera-frame-4"><a href="#how-can-we-get-viewing-matrix-v-from-the-camera-frame-4" class="header-anchor">#</a> How can we get viewing matrix V from the camera frame?</h2> <ul><li>카메라 프레임에서의 축 벡터(u, v, w)와 원점(P_eye)를 사용해 변환 행렬을 구성할 수 있다.</li> <li>이 행렬이 바로 <strong>Rigid transformation matrix</strong>이다.<div class="language- extra-class"><pre class="language-text"><code>| u_x  v_x  w_x  P_eye_x |
| u_y  v_y  w_y  P_eye_y |
| u_z  v_z  w_z  P_eye_z |
|  0     0     0     1   |
</code></pre></div></li></ul> <h2 id="viewing-transformation-is-the-opposite-direction"><a href="#viewing-transformation-is-the-opposite-direction" class="header-anchor">#</a> Viewing Transformation is the Opposite Direction</h2> <ul><li>Viewing matrix V는 위의 행렬의 역행렬로 정의된다.</li> <li>즉, <strong>반대 방향</strong>으로의 변환이다.<div class="language- extra-class"><pre class="language-text"><code>V = [ R  t ]^-1
  = [ R^T  -R^T * t ]
</code></pre></div></li></ul> <h2 id="inverting-rigid-transformation-matrix"><a href="#inverting-rigid-transformation-matrix" class="header-anchor">#</a> Inverting Rigid Transformation Matrix</h2> <ul><li>3×3 회전 행렬 R과 3×1 이동 벡터 t를 포함한 rigid 변환 행렬 T의 역행렬은 다음과 같다:<div class="language- extra-class"><pre class="language-text"><code>T = [ R  t ]
    [ 0  1 ]

T^-1 = [ R^T  -R^T * t ]
       [  0        1   ]
</code></pre></div></li> <li>카메라 프레임 행렬의 경우, R은 u, v, w 방향 벡터로 이루어진다.</li></ul> <h2 id="viewing-transformation-is-the-opposite-direction-2"><a href="#viewing-transformation-is-the-opposite-direction-2" class="header-anchor">#</a> Viewing Transformation is the Opposite Direction</h2> <ul><li>V는 다음과 같이 명시적으로 구성된다:<div class="language- extra-class"><pre class="language-text"><code>V =
| u_x  v_x  w_x  -u·P_eye |
| u_y  v_y  w_y  -v·P_eye |
| u_z  v_z  w_z  -w·P_eye |
|  0     0     0       1  |
</code></pre></div></li></ul> <h2 id="defining-camera-frame-2-translate-rotate"><a href="#defining-camera-frame-2-translate-rotate" class="header-anchor">#</a> Defining Camera Frame 2 - Translate &amp; Rotate</h2> <ul><li>&quot;LookAt&quot; 함수 외에도, 카메라의 위치와 방향을 정의할 수 있는 방법이 있다.</li> <li>단순히 <strong>translate</strong>하고 <strong>rotate</strong>하면 rigid transformation 행렬로 정의 가능하다.</li></ul> <h2 id="demo-translate-rotate-camera"><a href="#demo-translate-rotate-camera" class="header-anchor">#</a> [Demo] Translate &amp; Rotate Camera</h2> <ul><li>링크: <a href="http://learnwebgl.brown37.net/07_cameras/camera_trunk_axes/camera_trunk_axes.html" target="_blank" rel="noopener noreferrer">http://learnwebgl.brown37.net/07_cameras/camera_trunk_axes/camera_trunk_axes.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>슬라이더로 eye 위치를 바꾸거나 축 방향 및 각도를 지정해 회전하는 카메라 움직임을 시각적으로 관찰할 수 있다.</li></ul> <h2 id="moving-camera-vs-moving-world"><a href="#moving-camera-vs-moving-world" class="header-anchor">#</a> Moving Camera vs. Moving World</h2> <ul><li><p>사실, 이 둘은 <strong>동등한 연산</strong>이다.</p></li> <li><p>카메라를 (1, 0, 2)만큼 이동시키는 것은<br>
== 월드를 (-1, 0, -2)만큼 이동시키는 것과 같다.</p></li> <li><p>카메라를 y축 기준으로 <strong>60도 회전</strong>시키는 것은<br>
== 월드를 y축 기준으로 <strong>-60도 회전</strong>시키는 것과 같다.</p></li></ul> <h2 id="demo-moving-camera-vs-moving-world"><a href="#demo-moving-camera-vs-moving-world" class="header-anchor">#</a> [Demo] Moving Camera vs. Moving World</h2> <ul><li><p><a href="https://webglfundamentals.org/webgl/lessons/resources/camera-move-camera.html?mode=0" target="_blank" rel="noopener noreferrer">https://webglfundamentals.org/webgl/lessons/resources/camera-move-camera.html?mode=0<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://webglfundamentals.org/webgl/lessons/resources/camera-move-camera.html?mode=2" target="_blank" rel="noopener noreferrer">https://webglfundamentals.org/webgl/lessons/resources/camera-move-camera.html?mode=2<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>(Left) Moving camera</p></li> <li><p>(Center) Moving world</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/computer-graphics/4-Affine-Space-Frame_Matrix.html" class="prev">
        4-Affine-Space-Frame_Matrix
      </a></span> <span class="next"><a href="/computer-graphics/6-Vertex-Processing-2.html">
        6-Vertex-Processing-2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.3f9354f2.js" defer></script><script src="/assets/js/18.bb8e1e7a.js" defer></script><script src="/assets/js/2.a3ccddde.js" defer></script><script src="/assets/js/1.93e900e1.js" defer></script><script src="/assets/js/31.3f4b63f6.js" defer></script><script src="/assets/js/22.6bbde796.js" defer></script>
  </body>
</html>

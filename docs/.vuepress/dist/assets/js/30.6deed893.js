(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{350:function(t,r,a){"use strict";a.r(r);var e=a(30),s=Object(e.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_4-affine-space-frame-matrix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-affine-space-frame-matrix"}},[t._v("#")]),t._v(" 4 - Affine Space / Frame / Matrix")]),t._v(" "),r("h2",{attrs:{id:"updates-in-prev-lecture-slides-rigid-transformations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#updates-in-prev-lecture-slides-rigid-transformations"}},[t._v("#")]),t._v(" Updates in Prev. Lecture Slides – Rigid Transformations")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("모든 점 사이의 거리를 유지함"),r("br"),t._v("\n∥g(u) − g(v)∥ = ∥u − v∥, ∀u, v ∈ ℝ³")])]),t._v(" "),r("li",[r("p",[t._v('"Handedness"를 보존함')]),t._v(" "),r("ul",[r("li",[t._v("회전의 경우:"),r("br"),t._v("\ng(u) × g(v) = g(u × v), ∀u, v ∈ ℝ³"),r("br"),t._v("\n(reflection은 보존하지 않음)"),r("br"),t._v("\n(translation은 방향을 바꾸지 않으므로 영향을 주지 않음)")])])]),t._v(" "),r("li",[r("p",[t._v("일부 문헌에서는 reflection을 rigid transformation으로 분류하지만,"),r("br"),t._v("\n본 강의에서는 포함하지 않음")])])]),t._v(" "),r("h2",{attrs:{id:"outline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[t._v("#")]),t._v(" Outline")]),t._v(" "),r("ul",[r("li",[t._v("Affine Space - Point vs. Vector")]),t._v(" "),r("li",[t._v("Coordinate System & Reference Frame")]),t._v(" "),r("li",[t._v("Affine Transformation Matrix")]),t._v(" "),r("li",[t._v("Interpretation of Composite Transformations")])]),t._v(" "),r("h1",{attrs:{id:"affine-space-point-vs-vector"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#affine-space-point-vs-vector"}},[t._v("#")]),t._v(" Affine Space - Point vs. Vector")]),t._v(" "),r("h2",{attrs:{id:"affine-space-point-vs-vector-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#affine-space-point-vs-vector-2"}},[t._v("#")]),t._v(" Affine Space - Point vs. Vector")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("개념적으로 "),r("strong",[t._v("point와 vector는 매우 다름")])])]),t._v(" "),r("li",[r("p",[t._v("이 차이는 "),r("strong",[t._v("homogeneous coordinates")]),t._v("로 표현할 수 있음")])]),t._v(" "),r("li",[r("p",[t._v("이 강의에서는 affine space,"),r("br"),t._v(" "),r("strong",[t._v("point와 vector의 차이점")]),t._v(","),r("br"),t._v("\n그리고 그것이 homogeneous coordinates와"),r("br"),t._v("\n어떻게 연결되는지를 학습함")])]),t._v(" "),r("li",[r("p",[t._v("이 개념은 coordinate invariant 또는"),r("br"),t._v("\ncoordinate-free geometric programming이라고도 불림")])])]),t._v(" "),r("p",[t._v("(출처: http://mrl.snu.ac.kr/courses/CourseGraphics/index_2017spring.html)")]),t._v(" "),r("h2",{attrs:{id:"points"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points"}},[t._v("#")]),t._v(" Points")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("Point p, Point q")])]),t._v(" "),r("li",[r("p",[t._v("이 두 점을 더한 **“sum”**은 무엇인가?")])])]),t._v(" "),r("h2",{attrs:{id:"if-you-assume-coordinates"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#if-you-assume-coordinates"}},[t._v("#")]),t._v(" If you assume coordinates, …")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("p = (x₁, y₁), q = (x₂, y₂)")])]),t._v(" "),r("li",[r("p",[t._v("합: (x₁ + x₂, y₁ + y₂)")])])]),t._v(" "),r("p",[t._v("→ 이게 맞는가?"),r("br"),t._v("\n→ "),r("strong",[t._v("기하학적으로 의미가 있는가?")])]),t._v(" "),r("h2",{attrs:{id:"if-you-assume-coordinates-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#if-you-assume-coordinates-2"}},[t._v("#")]),t._v(" If you assume coordinates, …")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("동일한 좌표 표현에서,")])]),t._v(" "),r("li",[r("p",[t._v("p = (x₁, y₁), q = (x₂, y₂)")])]),t._v(" "),r("li",[r("p",[t._v("(x₁ + x₂, y₁ + y₂)는 단순한 합이 아닌,"),r("br"),t._v(" "),r("strong",[t._v("원점에서 p와 q까지 가는 vector의 합")]),t._v("으로 간주해야 함")])])]),t._v(" "),r("p",[t._v("→ "),r("strong",[t._v("Vector sum")])]),t._v(" "),r("h2",{attrs:{id:"if-you-select-a-different-origin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#if-you-select-a-different-origin"}},[t._v("#")]),t._v(" If you select a different origin, …")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("p = (x₁, y₁), q = (x₂, y₂)")])]),t._v(" "),r("li",[r("p",[t._v("(x₁ + x₂, y₁ + y₂)의 의미는"),r("br"),t._v(" "),r("strong",[t._v("좌표계(원점)가 어디인지에 따라 달라짐")])])]),t._v(" "),r("li",[r("p",[t._v("즉, "),r("strong",[t._v("다른 coordinate frame을 선택하면 결과도 달라짐")])])])]),t._v(" "),r("h2",{attrs:{id:"points-and-vectors"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points-and-vectors"}},[t._v("#")]),t._v(" Points and Vectors")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("point")]),t._v("는 좌표값으로 정의된 위치")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("vector")]),t._v("는 두 점 사이의 차이로 정의됨")])]),t._v(" "),r("li",[r("p",[t._v("원점이 정의되었다면, point는"),r("br"),t._v("\n원점에서 해당 point까지의 "),r("strong",[t._v("vector로 표현 가능")])])]),t._v(" "),r("li",[r("p",[t._v("하지만 coordinate-free 관점에서는"),r("br"),t._v(" "),r("strong",[t._v("point는 vector가 아님")])])])]),t._v(" "),r("h2",{attrs:{id:"points-vectors-are-different"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-are-different"}},[t._v("#")]),t._v(" Points & Vectors are Different!")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("수학적(또는 물리적)으로,")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("Point는 공간상의 위치")])]),t._v(" "),r("li",[r("strong",[t._v("Vector는 공간상의 변위")])])])]),t._v(" "),r("li",[r("p",[t._v("시간에 비유하면 다음과 같음:")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("datetime은 시간의 위치")])]),t._v(" "),r("li",[r("strong",[t._v("duration은 시간의 변위")])])])])]),t._v(" "),r("h2",{attrs:{id:"vector-and-affine-spaces"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vector-and-affine-spaces"}},[t._v("#")]),t._v(" Vector and Affine Spaces")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("Vector space")])]),t._v(" "),r("ul",[r("li",[t._v("벡터와 그 연산 포함")]),t._v(" "),r("li",[t._v("점은 포함하지 않음")])])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("Affine space")])]),t._v(" "),r("ul",[r("li",[t._v("vector space의 상위 개념")]),t._v(" "),r("li",[t._v("벡터, 점, 그에 관련된 연산 모두 포함")])])])]),t._v(" "),r("h2",{attrs:{id:"vector-spaces"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vector-spaces"}},[t._v("#")]),t._v(" Vector spaces")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("A "),r("strong",[t._v("vector space")]),t._v("는 다음으로 구성됨:")]),t._v(" "),r("ul",[r("li",[t._v("벡터 집합과")]),t._v(" "),r("li",[t._v("두 가지 연산:\n"),r("ul",[r("li",[t._v("벡터 간 덧셈")]),t._v(" "),r("li",[t._v("스칼라 곱")])])])])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("벡터들의 선형 결합(linear combination)")]),t._v(" 또한 벡터임")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("u₀, u₁, ..., uₙ ∈ V ⇒  \nc₀u₀ + c₁u₁ + ... + cₙuₙ ∈ V\n")])])]),r("h2",{attrs:{id:"affine-spaces"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#affine-spaces"}},[t._v("#")]),t._v(" Affine Spaces")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("An "),r("strong",[t._v("affine space")]),t._v("는 다음으로 구성됨:")]),t._v(" "),r("ul",[r("li",[t._v("점들의 집합, 관련된 벡터 공간,")]),t._v(" "),r("li",[t._v("두 가지 연산:\n"),r("ul",[r("li",[t._v("두 점의 차")]),t._v(" "),r("li",[t._v("점 + 벡터")])])])])])]),t._v(" "),r("h2",{attrs:{id:"coordinate-free-geometric-operations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-free-geometric-operations"}},[t._v("#")]),t._v(" Coordinate-Free Geometric Operations")]),t._v(" "),r("ul",[r("li",[t._v("덧셈 (Addition)")]),t._v(" "),r("li",[t._v("뺄셈 (Subtraction)")]),t._v(" "),r("li",[t._v("스칼라 곱 (Scalar multiplication)")])]),t._v(" "),r("h2",{attrs:{id:"addition"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#addition"}},[t._v("#")]),t._v(" Addition")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("u + v → "),r("strong",[t._v("벡터")])])]),t._v(" "),r("li",[r("p",[t._v("p + w → "),r("strong",[t._v("점")])])]),t._v(" "),r("li",[r("p",[t._v("u, v, w: vectors")])]),t._v(" "),r("li",[r("p",[t._v("p, q: points")])])]),t._v(" "),r("h2",{attrs:{id:"subtraction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#subtraction"}},[t._v("#")]),t._v(" Subtraction")]),t._v(" "),r("ul",[r("li",[t._v("u − v → 벡터")]),t._v(" "),r("li",[t._v("p − q → 벡터")]),t._v(" "),r("li",[t._v("p − w → 점")])]),t._v(" "),r("p",[t._v("(단, u, v, w: vectors / p, q: points)")]),t._v(" "),r("h2",{attrs:{id:"scalar-multiplication"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#scalar-multiplication"}},[t._v("#")]),t._v(" Scalar Multiplication")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("스칼라 × 벡터 = 벡터")])]),t._v(" "),r("li",[r("strong",[t._v("1 × 점 = 점")])]),t._v(" "),r("li",[r("strong",[t._v("0 × 점 = 벡터")])]),t._v(" "),r("li",[r("strong",[t._v("c × 점 = 정의되지 않음")]),t._v(" (단, c ≠ 0, 1일 때)")])]),t._v(" "),r("h2",{attrs:{id:"affine-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#affine-frame"}},[t._v("#")]),t._v(" Affine Frame")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("A "),r("strong",[t._v("frame")]),t._v("은 다음으로 정의됨:")]),t._v(" "),r("ul",[r("li",[t._v("벡터들의 집합 {vᵢ}, i = 1, ..., N")]),t._v(" "),r("li",[t._v("기준이 되는 점 o")])])]),t._v(" "),r("li",[r("p",[t._v("{vᵢ}는 해당 vector space의 "),r("strong",[t._v("basis")])])]),t._v(" "),r("li",[r("p",[t._v("o는 해당 frame의 "),r("strong",[t._v("origin")])])]),t._v(" "),r("li",[r("p",[t._v("N은 affine space의 "),r("strong",[t._v("차원")])])]),t._v(" "),r("li",[r("p",[t._v("임의의 점 p는 다음과 같이 표현됨:")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p = o + c₁v₁ + c₂v₂ + ... + cₙvₙ\n")])])]),r("ul",[r("li",[t._v("임의의 벡터 v는 다음과 같이 표현됨:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("v = c₁v₁ + c₂v₂ + ... + cₙvₙ\n")])])]),r("h2",{attrs:{id:"summary"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[t._v("#")]),t._v(" Summary")]),t._v(" "),r("ul",[r("li",[t._v("Affine space에서:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("point + point = 정의되지 않음  \npoint − point = vector  \npoint + vector = point  \nvector + vector = vector  \nscalar × vector = vector  \nscalar × point =  \n  - point (if scalar = 1)  \n  - vector (if scalar = 0)  \n  - undefined (otherwise)\n")])])]),r("h2",{attrs:{id:"points-vectors-in-homogeneous-coordinates"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-in-homogeneous-coordinates"}},[t._v("#")]),t._v(" Points & Vectors in Homogeneous Coordinates")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("Homogeneous coordinates에서는,")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("3D point")]),t._v(": (x, y, z, "),r("strong",[t._v("1")]),t._v(")")]),t._v(" "),r("li",[r("strong",[t._v("3D vector")]),t._v(": (x, y, z, "),r("strong",[t._v("0")]),t._v(")")])])])]),t._v(" "),r("p",[t._v("→ 이 표현은 coordinate-free geometric programming의"),r("br"),t._v("\n개념과 "),r("strong",[t._v("완전하게 일치하는 모델")]),t._v("을 제공함")]),t._v(" "),r("h2",{attrs:{id:"points-vectors-in-homogeneous-coordinates-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-in-homogeneous-coordinates-2"}},[t._v("#")]),t._v(" Points & Vectors in Homogeneous Coordinates")]),t._v(" "),r("p",[t._v("예시:")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("( x₁, y₁, z₁, 1 ) + ( x₂, y₂, z₂, 1 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 2 ) → point (정의 안 됨)  \n( x₁, y₁, z₁, 1 ) − ( x₂, y₂, z₂, 1 ) = ( x₁ − x₂, y₁ − y₂, z₁ − z₂, 0 ) → vector  \n( x₁, y₁, z₁, 1 ) + ( x₂, y₂, z₂, 0 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 1 ) → point  \n( x₁, y₁, z₁, 0 ) + ( x₂, y₂, z₂, 0 ) = ( x₁ + x₂, y₁ + y₂, z₁ + z₂, 0 ) → vector  \nc × ( x, y, z, 0 ) = ( cx, cy, cz, 0 ) → vector  \nc × ( x, y, z, 1 ) = ( cx, cy, cz, c ) →  \n  - point (if c = 1)  \n  - undefined (if c ≠ 0,1)\n")])])]),r("h2",{attrs:{id:"points-vectors-in-homogeneous-coordinates-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-in-homogeneous-coordinates-3"}},[t._v("#")]),t._v(" Points & Vectors in Homogeneous Coordinates")]),t._v(" "),r("ul",[r("li",[t._v("Affine transformation matrix × point, vector:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("[ M  t ]   [ p ]   = [ M * p + t ] → point  \n[ 0ᵀ 1 ]   [ 1 ]             [ 1 ]\n\n[ M  t ]   [ v ]   = [ M * v     ] → vector  \n[ 0ᵀ 1 ]   [ 0 ]             [ 0 ]\n")])])]),r("p",[t._v("→ "),r("strong",[t._v("translation은 vector에는 적용되지 않음!")])]),t._v(" "),r("h2",{attrs:{id:"quiz-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#quiz-1"}},[t._v("#")]),t._v(" Quiz 1")]),t._v(" "),r("h1",{attrs:{id:"coordinate-system-reference-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-system-reference-frame"}},[t._v("#")]),t._v(" Coordinate System & Reference Frame")]),t._v(" "),r("h2",{attrs:{id:"coordinate-system-reference-frame-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-system-reference-frame-2"}},[t._v("#")]),t._v(" Coordinate System & Reference Frame")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("Coordinate system")])]),t._v(" "),r("ul",[r("li",[t._v("점의 위치를 고유하게 결정하기 위해"),r("br"),t._v("\n하나 이상의 숫자 또는 좌표를 사용하는 체계")])])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("Reference frame")])]),t._v(" "),r("ul",[r("li",[t._v("추상적인 좌표계 + 실제 기준점")]),t._v(" "),r("li",[t._v("좌표계를 고정시키기 위해 사용됨")])])]),t._v(" "),r("li",[r("p",[t._v("이 두 용어는 종종 혼용되지만,"),r("br"),t._v(" "),r("strong",[t._v("의미에는 약간의 차이")]),t._v("가 있음")])])]),t._v(" "),r("h2",{attrs:{id:"world-body-frame-or-coordinate-system"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#world-body-frame-or-coordinate-system"}},[t._v("#")]),t._v(" World / Body Frame (or Coordinate System)")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("World frame (or coordinate system)")])]),t._v(" "),r("ul",[r("li",[t._v("세계에 고정된 좌표계")]),t._v(" "),r("li",[t._v("aka. global frame, fixed frame")])])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("Body frame (or coordinate system)")])]),t._v(" "),r("ul",[r("li",[t._v("물체에 고정된 좌표계")]),t._v(" "),r("li",[t._v("aka. local frame")])])])]),t._v(" "),r("p",[t._v("(예시 이미지: world frame과 body frame의 차이)")]),t._v(" "),r("h1",{attrs:{id:"affine-transformation-matrix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#affine-transformation-matrix"}},[t._v("#")]),t._v(" Affine Transformation Matrix")]),t._v(" "),r("h2",{attrs:{id:"meanings-of-affine-transformation-matrix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#meanings-of-affine-transformation-matrix"}},[t._v("#")]),t._v(" Meanings of Affine Transformation Matrix")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("하나의 affine transformation matrix")]),t._v("는"),r("br"),t._v(" "),r("strong",[t._v("여러 관점에서 해석 가능함")])])]),t._v(" "),r("h2",{attrs:{id:"_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame"}},[t._v("#")]),t._v(" 1) Affine Transformation Matrix Transforms a Geometry w.r.t. World Frame")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("행렬 M은 "),r("strong",[t._v("기하 객체의 각 vertex 위치를")]),r("br"),t._v(" "),r("strong",[t._v("world frame 기준에서 새로운 위치로 변환")])])]),t._v(" "),r("li",[r("p",[t._v("변환 포함: translate, rotate, scale 등")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("M =\n[ m11  m12  m13  tx ]  \n[ m21  m22  m23  ty ]  \n[ m31  m32  m33  tz ]  \n[  0    0    0   1  ]\n")])])]),r("ul",[r("li",[t._v("M을 곱하면 geometry가 world frame에서"),r("br"),t._v(" "),r("strong",[t._v("다른 위치로 이동된 결과를 얻음")])])]),t._v(" "),r("h2",{attrs:{id:"review-affine-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#review-affine-frame"}},[t._v("#")]),t._v(" Review: Affine Frame")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("Affine frame")]),t._v(" (3D 공간 기준)은 다음으로 정의됨:")]),t._v(" "),r("ul",[r("li",[t._v("x, y, z 축을 나타내는 3개의 벡터")]),t._v(" "),r("li",[t._v("1개의 원점 위치")])])])]),t._v(" "),r("p",[t._v("(도식: 세 벡터 + 한 점)")]),t._v(" "),r("h2",{attrs:{id:"world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#world-frame"}},[t._v("#")]),t._v(" World Frame")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("World frame")]),t._v("은 보통 다음으로 표현됨:")]),t._v(" "),r("ul",[r("li",[t._v("표준 축 벡터\n"),r("ul",[r("li",[t._v("êₓ = [1 0 0]ᵀ")]),t._v(" "),r("li",[t._v("êᵧ = [0 1 0]ᵀ")]),t._v(" "),r("li",[t._v("ê𝓏 = [0 0 1]ᵀ")])])]),t._v(" "),r("li",[t._v("원점 위치: 0")])])])]),t._v(" "),r("p",[t._v("(도식: 원점에서 출발하는 세 축 벡터)")]),t._v(" "),r("h2",{attrs:{id:"let-s-transform-a-world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#let-s-transform-a-world-frame"}},[t._v("#")]),t._v(' Let’s transform a "world frame"')]),t._v(" "),r("ul",[r("li",[t._v("M을 "),r("strong",[t._v("world frame에 곱하면")]),t._v(","),r("br"),t._v("\nx, y, z 축 벡터 및 원점에 각각 곱해지며 프레임이 변환됨:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("x axis vector:\nM × [1 0 0 0]ᵀ = 첫 번째 column  \ny axis vector:\nM × [0 1 0 0]ᵀ = 두 번째 column  \nz axis vector:\nM × [0 0 1 0]ᵀ = 세 번째 column  \norigin point:\nM × [0 0 0 1]ᵀ = 네 번째 column\n")])])]),r("h2",{attrs:{id:"_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"}},[t._v("#")]),t._v(" 2) Affine Transformation Matrix Defines an Affine Frame w.r.t. World Frame")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("행렬 M은 "),r("strong",[t._v("Affine Frame을 정의함")])]),t._v(" "),r("ul",[r("li",[t._v("(기준 프레임 {0} 기준으로 표현된 {1} 프레임)")])])]),t._v(" "),r("li",[r("p",[t._v("M의 각 column은 다음을 나타냄:")]),t._v(" "),r("ul",[r("li",[t._v("첫 3개 column: 축 벡터")]),t._v(" "),r("li",[t._v("마지막 column: 원점 위치")])])])]),t._v(" "),r("p",[t._v("→ M은 "),r("strong",[t._v("변환된 body frame {1}을 world frame {0} 기준으로 표현한 것")])]),t._v(" "),r("h2",{attrs:{id:"examples"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("같은 물체의 body frame이 두 가지 방식으로 정의됨:")]),t._v(" "),r("ul",[r("li",[t._v("(a) world frame과 body frame이 일치할 때")]),t._v(" "),r("li",[t._v("(b) body frame이 다른 위치에서 정의될 때")])])])]),t._v(" "),r("p",[t._v("→ 두 경우 모두 M은 body frame을 world frame 기준으로 표현함")]),t._v(" "),r("h2",{attrs:{id:"_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame"}},[t._v("#")]),t._v(" 3) Affine Transformation Matrix Transforms a Point Represented in an Affine Frame to the Same Point (but) Represented in World Frame")]),t._v(" "),r("ul",[r("li",[t._v("p^{(1)} = (1, 1, 0): body frame {1} 기준에서 본 점")]),t._v(" "),r("li",[t._v("M을 곱하면:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p^{(0)} = M * p^{(1)}\n")])])]),r("ul",[r("li",[t._v("즉, 같은 점을 world frame {0} 기준에서 표현한 것")])]),t._v(" "),r("h2",{attrs:{id:"_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame-because"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-affine-transformation-matrix-transforms-a-point-represented-in-an-affine-frame-to-the-same-point-but-represented-in-world-frame-because"}},[t._v("#")]),t._v(" 3) Affine Transformation Matrix Transforms a Point Represented in an Affine Frame to the Same Point (but) Represented in World Frame Because...")]),t._v(" "),r("ul",[r("li",[t._v("동일한 물체를 body frame 기준에서 보다가"),r("br"),t._v("\nM을 통해 "),r("strong",[t._v("world frame 기준 표현")]),t._v("으로 변환한 것")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p^{(0)} = M * p^{(1)}\n")])])]),r("ul",[r("li",[t._v("단순히 geometry를 변환한 이야기임")])]),t._v(" "),r("h2",{attrs:{id:"directions-of-the-arrow"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#directions-of-the-arrow"}},[t._v("#")]),t._v(' Directions of the "arrow"')]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("첫 번째 의미 (1st meaning)")]),t._v(" "),r("ul",[r("li",[t._v("geometry 자체를 transform (frame은 그대로)")]),t._v(" "),r("li",[t._v("M은 변환의 방향을 나타냄: {0} → {1}")])])])]),t._v(" "),r("p",[t._v("→ p^{(1)}가 변환되어 p^{(0)}이 됨")]),t._v(" "),r("h2",{attrs:{id:"directions-of-the-arrow-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#directions-of-the-arrow-2"}},[t._v("#")]),t._v(' Directions of the "arrow"')]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("두 번째 의미는 frame 자체의 변환")])]),t._v(" "),r("ul",[r("li",[t._v("{1} 프레임이 {0} 기준으로 어떻게 보이는지를 나타냄")])])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("세 번째 의미 (3rd meaning)")])]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("p라는 점이 표현되는 프레임 자체를 바꾸는 과정")])])])])]),t._v(" "),r("p",[t._v('→ "표현의 기준"이 바뀜: {1}에서 본 p를'),r("br"),t._v("\n{0}에서 본 p로 변환하는 것")]),t._v(" "),r("h2",{attrs:{id:"quiz-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#quiz-2"}},[t._v("#")]),t._v(" Quiz 2")]),t._v(" "),r("h2",{attrs:{id:"all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame"}},[t._v("#")]),t._v(" All these concepts work even if the starting frame is not world frame!")]),t._v(" "),r("ul",[r("li",[t._v("시작 프레임이 world frame이 아니어도, 지금까지의 모든 개념은 그대로 적용 가능")])]),t._v(" "),r("h2",{attrs:{id:"_0-to-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_0-to-1"}},[t._v("#")]),t._v(" {0} to {1}")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("M₁은 다음을 수행:")]),t._v(" "),r("ol",[r("li",[t._v("프레임 {0} 기준에서 geometry를 변환")]),t._v(" "),r("li",[t._v("프레임 {0} 기준에서 프레임 {1}을 정의")]),t._v(" "),r("li",[t._v("프레임 {1} 기준의 점을 {0} 기준으로 표현\n"),r("ul",[r("li",[t._v("p^{(0)} = M₁ * p^{(1)}")])])])])])]),t._v(" "),r("h2",{attrs:{id:"_1-to-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-to-2"}},[t._v("#")]),t._v(" {1} to {2}")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("M₂는 다음을 수행:")]),t._v(" "),r("ol",[r("li",[t._v("프레임 {1} 기준에서 geometry를 변환")]),t._v(" "),r("li",[t._v("프레임 {1} 기준에서 프레임 {2}를 정의")]),t._v(" "),r("li",[t._v("프레임 {2} 기준의 점을 {1} 기준으로 표현\n"),r("ul",[r("li",[t._v("p^{(1)} = M₂ * p^{(2)}")])])])])])]),t._v(" "),r("h2",{attrs:{id:"_0-to-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_0-to-2"}},[t._v("#")]),t._v(" {0} to {2}")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("M₁M₂는 다음을 수행:")]),t._v(" "),r("ol",[r("li",[t._v("프레임 {0} 기준에서 geometry를 변환")]),t._v(" "),r("li",[t._v("프레임 {0} 기준에서 프레임 {2}를 정의")]),t._v(" "),r("li",[t._v("프레임 {2} 기준의 점을 {0} 기준으로 표현\n"),r("ul",[r("li",[t._v("p^{(0)} = M₁ * M₂ * p^{(2)}")])])])])])]),t._v(" "),r("h1",{attrs:{id:"interpretation-of-composite-transformations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interpretation-of-composite-transformations"}},[t._v("#")]),t._v(" Interpretation of Composite Transformations")]),t._v(" "),r("h2",{attrs:{id:"revisit-order-matters"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#revisit-order-matters"}},[t._v("#")]),t._v(" Revisit: Order Matters!")]),t._v(" "),r("ul",[r("li",[t._v("T, R이 affine transformation을 나타내는 행렬일 때:")])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p' = T * R * p\n  → 먼저 R 적용 (p → R(p)), 그 후 T 적용\n\np' = R * T * p\n  → 먼저 T 적용 (p → T(p)), 그 후 R 적용\n")])])]),r("ul",[r("li",[t._v("→ "),r("strong",[t._v("행렬의 곱셈 순서는 매우 중요함!")]),t._v(" "),r("ul",[r("li",[t._v("곱셈은 결합법칙은 성립하지만 교환법칙은 성립하지 않음 (AB ≠ BA)")])])])]),t._v(" "),r("h2",{attrs:{id:"interpretation-of-composite-transformations-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interpretation-of-composite-transformations-1"}},[t._v("#")]),t._v(" Interpretation of Composite Transformations #1")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("예제 변환:"),r("br"),t._v("\nM = T(x,3) · R(−90°)")])]),t._v(" "),r("li",[r("p",[t._v("우리가 지금까지 해석한 방식:")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("R → T 순서로")]),t._v(" 적용")]),t._v(" "),r("li",[t._v("R은 world frame 기준 변환")])])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p → R(−90°)(p) → T(x,3) 적용 → p' = T(R(p))\n")])])]),r("h2",{attrs:{id:"interpretation-of-composite-transformations-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interpretation-of-composite-transformations-2"}},[t._v("#")]),t._v(" Interpretation of Composite Transformations #2")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("예제 변환 동일:"),r("br"),t._v("\nM = T(x,3) · R(−90°)")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("다른 해석 방식")]),t._v(":")]),t._v(" "),r("ul",[r("li",[t._v("R → T 순서가 아닌, "),r("strong",[t._v("T → R")]),t._v(" 순서로 해석")]),t._v(" "),r("li",[t._v("즉, "),r("strong",[t._v("body frame 기준")]),t._v("에서 해석하는 방식")])])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p → T(p) → R(T(p)) = M(p) = p'\n")])])]),r("ul",[r("li",[t._v("→ 동일한 행렬이라도 "),r("strong",[t._v("기준 프레임에 따라 해석이 달라질 수 있음")])])]),t._v(" "),r("h2",{attrs:{id:"pre-left-post-right-multiplication"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pre-left-post-right-multiplication"}},[t._v("#")]),t._v(" Pre-(left) & Post-(right) Multiplication")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p' = M₁M₂p  (pre-multiplication by M₁)\n→ R-to-L 순서\n")])])]),r("ol",[r("li",[t._v("M₂를 "),r("strong",[t._v("world frame 기준")]),t._v("으로 적용하여 p를 변환")]),t._v(" "),r("li",[t._v("그 결과를 M₁을 통해 "),r("strong",[t._v("world frame 기준")]),t._v("으로 다시 변환")])]),t._v(" "),r("p",[t._v("→ 전체 변환은 "),r("strong",[t._v("M₁M₂")])]),t._v(" "),r("hr"),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("p' = M₁M₂p  (post-multiplication by M₁)\n→ L-to-R 순서\n")])])]),r("ol",[r("li",[t._v("p는 body frame {1} 기준에서 표현되어 있고,"),r("br"),t._v("\nM₁은 "),r("strong",[t._v("body frame {1}을 world frame 기준으로 업데이트")]),t._v("함")]),t._v(" "),r("li",[t._v("M₂는 body frame {2}로 업데이트함")]),t._v(" "),r("li",[t._v("결과적으로 p는 body frame {2}에서 표현됨")])]),t._v(" "),r("p",[t._v("→ 전체 변환은 "),r("strong",[t._v("M₁M₂")])]),t._v(" "),r("p",[r("strong",[t._v("또 다른 유용한 해석법")])]),t._v(" "),r("ol",[r("li",[t._v("M₁을 world frame 기준으로 적용하여 "),r("strong",[t._v("body frame을 M₁으로 업데이트")])]),t._v(" "),r("li",[t._v("M₂를 world frame 기준으로 적용하여 "),r("strong",[t._v("body frame을 M₁M₂로 업데이트")])]),t._v(" "),r("li",[t._v("p를 새 body frame M₁M₂ 기준으로 위치시킴")])]),t._v(" "),r("h2",{attrs:{id:"demo-l-to-r-r-to-l-interpretation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#demo-l-to-r-r-to-l-interpretation"}},[t._v("#")]),t._v(" [Demo] L-to-R & R-to-L Interpretation")]),t._v(" "),r("p",[t._v("https://observablehq.com/@esperanc/transformation-demo")]),t._v(" "),r("ul",[r("li",[t._v("다양한 순서로 translation 및 선형 변환 추가 ( '+' 버튼 사용)")]),t._v(" "),r("li",[t._v("슬라이더를 드래그하여 행렬 값의 변화 및 도형의 변화를 관찰")]),t._v(" "),r("li",[t._v("합성 변환의 의미를 "),r("strong",[t._v("L-to-R")]),t._v(", "),r("strong",[t._v("R-to-L")]),t._v(" 순서로 해석해보세요")])])])}),[],!1,null,null,null);r.default=s.exports}}]);
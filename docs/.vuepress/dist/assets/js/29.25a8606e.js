(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{351:function(a,t,s){"use strict";s.r(t);var n=s(20),r=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_3-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-transformations"}},[a._v("#")]),a._v(" 3 - Transformations")]),a._v(" "),t("h2",{attrs:{id:"outline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[a._v("#")]),a._v(" Outline")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("2차원 변환")]),a._v(" "),t("ul",[t("li",[a._v("Scaling, Rotation, Shearing, Reflection")]),a._v(" "),t("li",[a._v("Translation")])])]),a._v(" "),t("li",[t("p",[a._v("변환의 종류")])]),a._v(" "),t("li",[t("p",[a._v("변환의 합성과 Homogeneous Coordinates")])]),a._v(" "),t("li",[t("p",[a._v("두 가지 3차원 직교 좌표계")])]),a._v(" "),t("li",[t("p",[a._v("3차원 Affine 변환")])])]),a._v(" "),t("h2",{attrs:{id:"what-is-transformation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-is-transformation"}},[a._v("#")]),a._v(" What is Transformation?")]),a._v(" "),t("ul",[t("li",[t("p",[t("strong",[a._v("Geometric Transformation")])]),a._v(" "),t("ul",[t("li",[t("p",[a._v("물체의 위치, 방향, 크기 또는 형태를 수학적으로 변경하는 과정"),t("br"),a._v("\n→ “점들의 집합을 이동시키는 것”")])]),a._v(" "),t("li",[t("p",[a._v("복잡한 장면과 애니메이션 생성을 가능하게 하며, computer graphics에서 필수적임")])])])]),a._v(" "),t("li",[t("p",[a._v("예시:")]),a._v(" "),t("ul",[t("li",[a._v("Translation")]),a._v(" "),t("li",[a._v("Rotation")]),a._v(" "),t("li",[a._v("Scaling")]),a._v(" "),t("li",[a._v("Shearing")])])])]),a._v(" "),t("h1",{attrs:{id:"_2d-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-transformations"}},[a._v("#")]),a._v(" 2D Transformations")]),a._v(" "),t("h2",{attrs:{id:"transformation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#transformation"}},[a._v("#")]),a._v(" Transformation")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("“점들의 집합을 이동시키는 것”")])]),a._v(" "),t("li",[t("p",[a._v("변환 T는 벡터 공간 S에 있는 임의의 입력 벡터 v를 T(v)로 사상함")]),a._v(" "),t("p",[a._v("수식 표현:\nS → { T(v) | v ∈ S }")])])]),a._v(" "),t("p",[a._v("(사각형이 평행이동되는 그림 예시)")]),a._v(" "),t("h2",{attrs:{id:"linear-transformation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformation"}},[a._v("#")]),a._v(" Linear Transformation")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("행렬 곱을 통해 변환을 정의할 수 있음")]),a._v(" "),t("p",[a._v("T(v) = Mv")])]),a._v(" "),t("li",[t("p",[a._v("이는 행렬 곱셈이 선형 사상을 나타내므로"),t("br"),a._v(" "),t("strong",[a._v("linear transformation")]),a._v("이라 부름")])]),a._v(" "),t("li",[t("p",[a._v("linear transformation은 다음 조건을 만족해야 함:")])])]),a._v(" "),t("p",[a._v("$$\nT(v_1 + v_2) = T(v_1) + T(v_2)\n$$")]),a._v(" "),t("p",[a._v("$$\nT(c \\cdot v) = c \\cdot T(v)\n$$")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("행렬 M 또한 동일한 선형성을 만족:")]),a._v(" "),t("p",[a._v("M(v₁ + v₂) = Mv₁ + Mv₂"),t("br"),a._v("\nM(c * v)   = c * (Mv)")])])]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-transformations"}},[a._v("#")]),a._v(" 2D Linear Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("2×2 행렬은 다음과 같은 2차원 linear transformation을 표현할 수 있음:")]),a._v(" "),t("ul",[t("li",[a._v("uniform scaling")]),a._v(" "),t("li",[a._v("non-uniform scaling")]),a._v(" "),t("li",[a._v("rotation")]),a._v(" "),t("li",[a._v("shearing")]),a._v(" "),t("li",[a._v("reflection")])])])]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-uniform-scaling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-uniform-scaling"}},[a._v("#")]),a._v(" 2D Linear Trans. – Uniform Scaling")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("x축과 y축 모두에서 동일한 비율로 확대 또는 축소")])]),a._v(" "),t("li",[t("p",[a._v("수식 예:")]),a._v(" "),t("p",[a._v("p = [ x"),t("br"),a._v("\ny ]")]),a._v(" "),t("p",[a._v("S = [ sx   0"),t("br"),a._v("\n0  sy ]")]),a._v(" "),t("p",[a._v("p' = S * p = [ sx * x"),t("br"),a._v("\nsy * y ]")])])]),a._v(" "),t("p",[a._v("(예: sx = sy = 1.5일 때 도형이 1.5배 확대됨)")]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-nonuniform-scaling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-nonuniform-scaling"}},[a._v("#")]),a._v(" 2D Linear Trans. – Nonuniform Scaling")]),a._v(" "),t("ul",[t("li",[a._v("x축과 y축 방향으로 "),t("strong",[a._v("서로 다른 비율로")]),a._v(" 확대 또는 축소")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("S = [ sx   0 ]    p = [ x ]     S * p = [ sx * x ]\n    [ 0   sy ]        [ y ]             [ sy * y ]\n")])])]),t("p",[a._v("(예: sx = 1.5, sy = 0.8 → x축 방향은 확대, y축 방향은 축소)")]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-rotation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-rotation"}},[a._v("#")]),a._v(" 2D Linear Trans. – Rotation")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("회전은 행렬 곱으로 표현 가능하며, 따라서 선형 변환임")])]),a._v(" "),t("li",[t("p",[a._v("양의 각도는 반시계 방향(CCW)을 의미함")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("회전 행렬 Rθ =\n[ cosθ  -sinθ ]  \n[ sinθ   cosθ ]\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Rθ * [ x ] = [ x * cosθ - y * sinθ ]\n     [ y ]   [ x * sinθ + y * cosθ ]\n")])])]),t("p",[a._v("(예: θ = 30도 → 30도 반시계 회전)")]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-rotation-예시-수치-포함"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-rotation-예시-수치-포함"}},[a._v("#")]),a._v(" 2D Linear Trans. – Rotation (예시 수치 포함)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("R = [ 0.866  -0.5   ]     p = [ x ]     R * p = [ 0.866x - 0.5y ]\n    [ 0.5     0.866 ]         [ y ]             [ 0.5x + 0.866y ]\n")])])]),t("p",[a._v("(30도 반시계 회전 시 적용되는 회전 행렬)")]),a._v(" "),t("h2",{attrs:{id:"numbers-in-matrices-scaling-rotation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#numbers-in-matrices-scaling-rotation"}},[a._v("#")]),a._v(" Numbers in Matrices: Scaling, Rotation")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("행렬의 "),t("strong",[a._v("각 숫자는 어떤 의미를 가질까?")])])]),a._v(" "),t("li",[t("p",[a._v("단위 벡터([1, 0]^T, [0, 1]^T)를 기준으로 scaling 또는 rotation 시"),t("br"),a._v("\n각각의 column vector가 변환된 축의 방향을 나타냄")])]),a._v(" "),t("li",[t("p",[a._v("Canonical basis vectors: 직교 좌표계에서 x, y축 방향 단위 벡터")])]),a._v(" "),t("li",[t("p",[a._v("결과적으로, 변환된 좌표계의 축 방향을 나타냄")])])]),a._v(" "),t("h2",{attrs:{id:"numbers-in-matrices-scaling-rotation-계속"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#numbers-in-matrices-scaling-rotation-계속"}},[a._v("#")]),a._v(" Numbers in Matrices: Scaling, Rotation (계속)")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("행렬의 "),t("strong",[a._v("column vector")]),a._v("는 그 행렬의 column space를 구성하는 "),t("strong",[a._v("basis vectors")])])]),a._v(" "),t("li",[t("p",[a._v("column space: column vector들의 선형 결합으로 표현 가능한 모든 벡터의 집합")])])]),a._v(" "),t("p",[a._v("(예시 이미지: rotation과 scaling 시 column vector들이 어떻게 변화하는지 시각화)")]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-reflection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-reflection"}},[a._v("#")]),a._v(" 2D Linear Trans. – Reflection")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Reflection은 "),t("strong",[a._v("non-uniform scaling의 특수한 경우")]),a._v("로 간주 가능")])]),a._v(" "),t("li",[t("p",[a._v("예시: x축 방향 반전")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ -1   0 ]   * [ x ]   = [ -x ]\n[  0   1 ]     [ y ]     [  y ]\n")])])]),t("p",[a._v("(좌우 반전된 이미지 예시 포함)")]),a._v(" "),t("h2",{attrs:{id:"_2d-linear-trans-shearing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-shearing"}},[a._v("#")]),a._v(" 2D Linear Trans. – Shearing")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("물체를 "),t("strong",[a._v("측면으로 밀기(push sideways)")])])]),a._v(" "),t("li",[t("p",[a._v("예시: x축 기준으로 y에 비례하여 x 이동")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ 1   a ]   * [ x ]   = [ x + a*y ]\n[ 0   1 ]     [ y ]     [   y     ]\n")])])]),t("p",[a._v("(예: a = 0.5 → 오른쪽으로 밀린 도형 예시 포함)")]),a._v(" "),t("h2",{attrs:{id:"identity-matrix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#identity-matrix"}},[a._v("#")]),a._v(" Identity Matrix")]),a._v(" "),t("ul",[t("li",[a._v("아무런 변환도 수행하지 않는 행렬 → "),t("strong",[a._v('"Doing nothing"')])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ 1   0 ]   * [ x ]   = [ x ]\n[ 0   1 ]     [ y ]     [ y ]\n")])])]),t("p",[a._v("(도형의 위치, 크기, 방향이 유지됨)")]),a._v(" "),t("h2",{attrs:{id:"demo-2d-linear-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#demo-2d-linear-transformations"}},[a._v("#")]),a._v(" [Demo] 2D Linear Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("https://www.integral-domain.org/williams/Applets/algebra/linearTransformations.php")])]),a._v(" "),t("li",[t("p",[a._v("행렬 요소의 값을 바꿔보세요")])]),a._v(" "),t("li",[t("p",[a._v("다양한 변환 버튼을 눌러보세요")])])]),a._v(" "),t("h2",{attrs:{id:"quiz-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quiz-1"}},[a._v("#")]),a._v(" Quiz 1")]),a._v(" "),t("ul",[t("li",[a._v("반드시 위 형식에 맞게 제출해야 출석으로 인정됩니다")])]),a._v(" "),t("h2",{attrs:{id:"_2d-translation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2d-translation"}},[a._v("#")]),a._v(" 2D Translation")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Translation은 가장 간단한 변환:"),t("br"),a._v("\nT(v) = v + u")])]),a._v(" "),t("li",[t("p",[a._v("역변환(Inverse):"),t("br"),a._v("\nT⁻¹(v) = v − u")])])]),a._v(" "),t("p",[a._v("(도식: v 벡터에서 u만큼 이동한 결과가 T(v))")]),a._v(" "),t("h2",{attrs:{id:"is-translation-linear-transformation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#is-translation-linear-transformation"}},[a._v("#")]),a._v(" Is translation linear transformation?")]),a._v(" "),t("ul",[t("li",[t("p",[t("strong",[a._v("아니오. 선형 변환(linear transformation)이 아님")])])]),a._v(" "),t("li",[t("p",[a._v("선형성(linearity)을 만족하지 않음:"),t("br"),a._v("\nT(v₁ + v₂) ≠ T(v₁) + T(v₂)"),t("br"),a._v("\nT(cv) ≠ cT(v)")]),a._v(" "),t("p",[a._v("예:"),t("br"),a._v("\ncT(v) = c(v + b) = cv + cb ≠ T(cv) = cv + b")])]),a._v(" "),t("li",[t("p",[a._v("벡터 덧셈을 사용해 표현 가능:"),t("br"),a._v("\nT(v) = v + u")])]),a._v(" "),t("li",[t("p",[a._v("선형 변환과 결합할 수 있음:"),t("br"),a._v("\nT(v) = Mv + u")])]),a._v(" "),t("li",[t("p",[a._v("→ "),t("strong",[a._v("Affine transformation")])])])]),a._v(" "),t("h2",{attrs:{id:"let-s-check-again"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let-s-check-again"}},[a._v("#")]),a._v(" Let’s check again")]),a._v(" "),t("ul",[t("li",[t("p",[t("strong",[a._v("Linear transformation")])]),a._v(" "),t("ul",[t("li",[a._v("Scaling, Rotation, Reflection, Shearing")]),a._v(" "),t("li",[a._v("행렬 곱셈으로 표현 가능"),t("br"),a._v("\nT(v) = Mv")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("Translation")])]),a._v(" "),t("ul",[t("li",[a._v("선형 변환이 아님")]),a._v(" "),t("li",[a._v("벡터 덧셈으로 표현됨"),t("br"),a._v("\nT(v) = v + u")])])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("Affine transformation")])]),a._v(" "),t("ul",[t("li",[a._v("선형 변환과 translation을 결합한 형태"),t("br"),a._v("\nT(v) = Mv + u")])])])]),a._v(" "),t("h1",{attrs:{id:"classes-of-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classes-of-transformations"}},[a._v("#")]),a._v(" Classes of Transformations")]),a._v(" "),t("h2",{attrs:{id:"rigid-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rigid-transformations"}},[a._v("#")]),a._v(" Rigid Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("모든 점 사이의 거리를 유지함")]),a._v(" "),t("p",[a._v("∥g(v) − g(w)∥ = ∥v − w∥"),t("br"),a._v("\n∀v, w ∈ ℝ² (g: rigid transformation)")])]),a._v(" "),t("li",[t("p",[a._v('"Handedness"를 보존함')]),a._v(" "),t("ul",[t("li",[a._v("회전(rotation)의 경우 handedness 보존 조건:"),t("br"),a._v("\ng(v) = Rv + t, ∀v ∈ ℝ²"),t("br"),a._v("\n(Reflection은 보존하지 않음)"),t("br"),a._v("\n(Translation은 방향을 바꾸지 않으므로 영향을 주지 않음)")])])]),a._v(" "),t("li",[t("p",[a._v("Rigid transformation의 예:")]),a._v(" "),t("ul",[t("li",[a._v("Translation")]),a._v(" "),t("li",[a._v("Identity")]),a._v(" "),t("li",[a._v("Rotation")])])]),a._v(" "),t("li",[t("p",[a._v("일부 문헌에서는 reflection을 rigid로 분류하기도 하나, 본 강의에서는 포함하지 않음")])])]),a._v(" "),t("h2",{attrs:{id:"similarity-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#similarity-transformations"}},[a._v("#")]),a._v(" Similarity Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("각도를 보존함")]),a._v(" "),t("ul",[t("li",[a._v("(rigid transformation도 각도 보존 포함)")])])]),a._v(" "),t("li",[t("p",[a._v("Similarity transformation의 예:")]),a._v(" "),t("ul",[t("li",[a._v("Translation")]),a._v(" "),t("li",[a._v("Identity")]),a._v(" "),t("li",[a._v("Rotation")]),a._v(" "),t("li",[t("strong",[a._v("Uniform Scaling")])])])]),a._v(" "),t("li",[t("p",[a._v("일부 문헌에서는 reflection도 포함하나, 본 강의에서는 다루지 않음")])])]),a._v(" "),t("h2",{attrs:{id:"linear-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations"}},[a._v("#")]),a._v(" Linear Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("원점을 보존함")])]),a._v(" "),t("li",[t("p",[a._v("포함되는 변환들:")]),a._v(" "),t("ul",[t("li",[a._v("Translation")]),a._v(" "),t("li",[a._v("Identity")]),a._v(" "),t("li",[a._v("Rotation")]),a._v(" "),t("li",[a._v("Uniform Scaling")]),a._v(" "),t("li",[a._v("Scaling")]),a._v(" "),t("li",[a._v("Reflection")]),a._v(" "),t("li",[a._v("Shearing")])])])]),a._v(" "),t("p",[a._v("(도식: Linear은 Similarity, Rigid, Affine을 모두 포함하는 개념)")]),a._v(" "),t("h2",{attrs:{id:"affine-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#affine-transformations"}},[a._v("#")]),a._v(" Affine Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("평행선을 유지함")])]),a._v(" "),t("li",[t("p",[a._v("직선 상의 거리 비율을 유지함")])]),a._v(" "),t("li",[t("p",[a._v("Affine 변환의 포함 관계:")]),a._v(" "),t("ul",[t("li",[a._v("Rigid ⊂ Similarity ⊂ Affine ⊂ Linear")])])])]),a._v(" "),t("h2",{attrs:{id:"projective-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#projective-transformations"}},[a._v("#")]),a._v(" Projective Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("직선을 보존함")])]),a._v(" "),t("li",[t("p",[a._v("포함 관계:")]),a._v(" "),t("ul",[t("li",[a._v("Rigid ⊂ Similarity ⊂ Affine ⊂ Linear ⊂ Projective")])])]),a._v(" "),t("li",[t("p",[a._v("가장 바깥쪽 계층은 Perspective 변환")])])]),a._v(" "),t("h1",{attrs:{id:"composition-of-transformations-homogeneous-coordinates"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composition-of-transformations-homogeneous-coordinates"}},[a._v("#")]),a._v(" Composition of Transformations & Homogeneous Coordinates")]),a._v(" "),t("h2",{attrs:{id:"composition-of-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composition-of-transformations"}},[a._v("#")]),a._v(" Composition of Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("어떤 물체에 T 변환을 적용한 후, S 변환을 추가 적용:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("p → T(p) → S(T(p)) = (S ∘ T)(p)\n")])])])]),a._v(" "),t("li",[t("p",[a._v("2D linear transformation의 합성은"),t("br"),a._v("\n2×2 행렬 곱셈으로 표현 가능:")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("T(p) = M_T * p  \nS(p) = M_S * p\n\n(S ∘ T)(p) = M_S * M_T * p\n           = (M_S M_T)(p)\n")])])]),t("h2",{attrs:{id:"order-matters"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#order-matters"}},[a._v("#")]),a._v(" Order Matters!")]),a._v(" "),t("ul",[t("li",[a._v("행렬 곱셈은 결합법칙은 성립하지만"),t("br"),a._v("\n교환법칙은 성립하지 않음:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(AB)C = A(BC)  \nAB ≠ BA\n")])])]),t("ul",[t("li",[a._v("따라서, "),t("strong",[a._v("변환의 적용 순서가 매우 중요함")])])]),a._v(" "),t("p",[a._v("(예: Scale → Rotate vs Rotate → Scale 결과가 다름)")]),a._v(" "),t("h2",{attrs:{id:"demo-composition-of-linear-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#demo-composition-of-linear-transformations"}},[a._v("#")]),a._v(" [Demo] Composition of Linear Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("https://www.integral-domain.org/williams/Applets/algebra/linearTransformations.php")])]),a._v(" "),t("li",[t("p",[a._v("identity matrix로 초기화 (1 0 0 1 입력)")])]),a._v(" "),t("li",[t("p",[a._v('"Compose Transformations" 버튼 클릭')])]),a._v(" "),t("li",[t("p",[a._v("두 개의 변환을 서로 다른 순서로 적용해보기")])])]),a._v(" "),t("h2",{attrs:{id:"problems-when-handling-translation-as-vector-addition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#problems-when-handling-translation-as-vector-addition"}},[a._v("#")]),a._v(" Problems when handling Translation as Vector Addition")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("선형 변환(회전, 스케일 등)과 translation을"),t("br"),a._v(" "),t("strong",[a._v("일관된 방식으로 표현할 수 없음")])])]),a._v(" "),t("li",[t("p",[a._v("Affine 변환의 합성은 복잡해짐:")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("T(p) = M_T * p + u_T  \nS(p) = M_S * p + u_S\n\n(S ∘ T)(p) = M_S(M_T * p + u_T) + u_S  \n           = (M_S M_T) * p + (M_S * u_T + u_S)\n")])])]),t("ul",[t("li",[a._v("우리는 더 깔끔한 표현 방식이 필요함"),t("br"),a._v("\n→ "),t("strong",[a._v("Homogeneous coordinates")])])]),a._v(" "),t("h2",{attrs:{id:"homogeneous-coordinates"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#homogeneous-coordinates"}},[a._v("#")]),a._v(" Homogeneous Coordinates")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("핵심 아이디어: 2D 점을 3D 좌표계 상에 표현")])]),a._v(" "),t("li",[t("p",[a._v("벡터에는 추가 성분(w), 행렬에는 추가 행/열을 추가")]),a._v(" "),t("ul",[t("li",[a._v("점에는 항상 w = 1")]),a._v(" "),t("li",[a._v("2D 점 (x, y)^T → (x, y, 1)^T")])])]),a._v(" "),t("li",[t("p",[a._v("2D linear transformation의 표현:")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ a  b  0 ]   [ x ]     [ ax + by ]\n[ c  d  0 ] * [ y ]  =  [ cx + dy ]\n[ 0  0  1 ]   [ 1 ]     [   1     ]\n")])])]),t("h2",{attrs:{id:"homogeneous-coordinates-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#homogeneous-coordinates-2"}},[a._v("#")]),a._v(" Homogeneous Coordinates")]),a._v(" "),t("ul",[t("li",[a._v("2D translation의 표현:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ 1  0  t ]   [ x ]     [ x + t ]\n[ 0  1  s ] * [ y ]  =  [ y + s ]\n[ 0  0  1 ]   [ 1 ]     [   1   ]\n")])])]),t("ul",[t("li",[a._v("2D affine transformation의 표현:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12  u1 ]  \n[ m21  m22  u2 ]   ← linear part + translational part\n[  0    0    1 ]\n")])])]),t("h2",{attrs:{id:"homogeneous-coordinates-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#homogeneous-coordinates-3"}},[a._v("#")]),a._v(" Homogeneous Coordinates")]),a._v(" "),t("ul",[t("li",[a._v("affine transformation 합성은 3×3 행렬 곱셈으로 간단하게 처리 가능:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("T(p) = M_T * p + u_T  \nS(p) = M_S * p + u_S\n")])])]),t("p",[a._v("→ block 행렬 표현:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("T(p) = [ M_T  u_T ]   * [ p ]\n       [  0    1  ]     [ 1 ]\n")])])]),t("h2",{attrs:{id:"homogeneous-coordinates-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#homogeneous-coordinates-4"}},[a._v("#")]),a._v(" Homogeneous Coordinates")]),a._v(" "),t("ul",[t("li",[a._v("affine transformation의 합성은 3×3 행렬 곱셈으로 처리됨")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(S ∘ T)(p) = [ M_S  u_S ] * [ M_T  u_T ] * [ p ]\n             [  0    1  ]   [  0    1  ]   [ 1 ]\n")])])]),t("p",[a._v("=>")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("      = [ M_S * M_T        M_S * u_T + u_S ] * [ p ]\n        [     0                     1      ]   [ 1 ]\n")])])]),t("ul",[t("li",[t("p",[a._v("결과는 이전 방식과 같지만 "),t("strong",[a._v("훨씬 간단하고 깔끔함")])])]),a._v(" "),t("li",[t("p",[a._v("기존 표현과 비교:")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(S ∘ T)(p) = M_S(M_T * p + u_T) + u_S  \n           = (M_S * M_T) * p + (M_S * u_T + u_S)\n")])])]),t("h2",{attrs:{id:"demo-composition-of-affine-transformations-in-homogeneous-coordinates"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#demo-composition-of-affine-transformations-in-homogeneous-coordinates"}},[a._v("#")]),a._v(" [Demo] Composition of Affine Transformations in Homogeneous Coordinates")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("https://observablehq.com/@esperanc/transformations-demo")])]),a._v(" "),t("li",[t("p",[a._v("‘+’ 버튼으로 다양한 순서의 translation 및 linear transformation 추가")])]),a._v(" "),t("li",[t("p",[a._v("슬라이더로 행렬 값의 변화와 도형 변형 확인")])]),a._v(" "),t("li",[t("p",[a._v("주의: 마지막에 추가된 변환이 "),t("strong",[a._v("가장 먼저 적용")]),a._v("됨")])])]),a._v(" "),t("h2",{attrs:{id:"summary-homogeneous-coordinates-in-2d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#summary-homogeneous-coordinates-in-2d"}},[a._v("#")]),a._v(" Summary: Homogeneous Coordinates in 2D")]),a._v(" "),t("ul",[t("li",[a._v("2D 점에는 (x, y)^T 대신 (x, y, 1)^T 사용")]),a._v(" "),t("li",[a._v("2D linear transformation에는 2×2 행렬 대신 "),t("strong",[a._v("3×3 행렬")]),a._v(" 사용")]),a._v(" "),t("li",[a._v("2D translation에도 벡터 덧셈 대신 "),t("strong",[a._v("3×3 행렬")]),a._v(" 사용")])]),a._v(" "),t("p",[a._v("→ linear transformation과 translation을"),t("br"),a._v(" "),t("strong",[a._v("일관된 방식으로 처리할 수 있음!")])]),a._v(" "),t("h2",{attrs:{id:"quiz-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quiz-2"}},[a._v("#")]),a._v(" Quiz 2")]),a._v(" "),t("h1",{attrs:{id:"two-types-of-3d-cartesian-coordinate-system"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#two-types-of-3d-cartesian-coordinate-system"}},[a._v("#")]),a._v(" Two Types of 3D Cartesian Coordinate System")]),a._v(" "),t("h2",{attrs:{id:"now-let-s-go-to-the-3d-world"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#now-let-s-go-to-the-3d-world"}},[a._v("#")]),a._v(" Now, Let’s go to the 3D world!")]),a._v(" "),t("ul",[t("li",[a._v("Coordinate system (좌표계)\n"),t("ul",[t("li",[a._v("Cartesian coordinate system (직교좌표계)")])])])]),a._v(" "),t("p",[a._v("(이미지: 2D 좌표계 → z축이 포함된 3D 좌표계로 확장됨)")]),a._v(" "),t("h2",{attrs:{id:"right-handed-and-left-handed-coordinate-systems"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#right-handed-and-left-handed-coordinate-systems"}},[a._v("#")]),a._v(" Right-Handed and Left-Handed Coordinate Systems")]),a._v(" "),t("ul",[t("li",[a._v("우리가 사용하는 시스템: "),t("strong",[a._v("Right-handed Cartesian Coordinates")])])]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("항목")]),a._v(" "),t("th",[a._v("Right-handed")]),a._v(" "),t("th",[a._v("Left-handed")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("회전 방향")]),a._v(" "),t("td",[a._v("축 기준 반시계 방향")]),a._v(" "),t("td",[a._v("축 기준 시계 방향")])]),a._v(" "),t("tr",[t("td",[a._v("사용 예시")]),a._v(" "),t("td",[a._v("OpenGL, Maya, Houdini, AutoCAD, Physics & Math")]),a._v(" "),t("td",[a._v("DirectX, Unity, Unreal 등")])])])]),a._v(" "),t("p",[a._v("(이미지: 오른손 법칙과 왼손 법칙 설명)")]),a._v(" "),t("h1",{attrs:{id:"_3d-affine-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3d-affine-transformations"}},[a._v("#")]),a._v(" 3D Affine Transformations")]),a._v(" "),t("h2",{attrs:{id:"point-representations-in-cartesian-homogeneous-coordinate-system"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#point-representations-in-cartesian-homogeneous-coordinate-system"}},[a._v("#")]),a._v(" Point Representations in Cartesian & Homogeneous Coordinate System")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th"),a._v(" "),t("th",[a._v("Cartesian coordinate system")]),a._v(" "),t("th",[a._v("Homogeneous coordinate system")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("A 2D point is represented as")]),a._v(" "),t("td",[a._v("[ px  py ]^T")]),a._v(" "),t("td",[a._v("[ px  py  1 ]^T")])]),a._v(" "),t("tr",[t("td",[a._v("A 3D point is represented as")]),a._v(" "),t("td",[a._v("[ px  py  pz ]^T")]),a._v(" "),t("td",[a._v("[ px  py  pz  1 ]^T")])])])]),a._v(" "),t("h2",{attrs:{id:"review-of-linear-transformations-in-2d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#review-of-linear-transformations-in-2d"}},[a._v("#")]),a._v(" Review of Linear Transformations in 2D")]),a._v(" "),t("ul",[t("li",[a._v("2D에서의 선형 변환은 다음과 같은 행렬 곱셈으로 표현됨:")])]),a._v(" "),t("p",[t("strong",[a._v("Cartesian coordinates:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12 ]   * [ px ]   = ...\n[ m21  m22 ]     [ py ]\n")])])]),t("p",[t("strong",[a._v("Homogeneous coordinates:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12   0 ]   [ px ]  \n[ m21  m22   0 ] * [ py ]  \n[  0    0    1 ]   [ 1  ]\n")])])]),t("h2",{attrs:{id:"linear-transformations-in-3d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d"}},[a._v("#")]),a._v(" Linear Transformations in 3D")]),a._v(" "),t("ul",[t("li",[a._v("3D에서의 선형 변환은 다음 행렬 곱셈으로 표현됨:")])]),a._v(" "),t("p",[t("strong",[a._v("Cartesian coordinates:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12  m13 ]   [ px ]  \n[ m21  m22  m23 ] * [ py ]  \n[ m31  m32  m33 ]   [ pz ]\n")])])]),t("p",[t("strong",[a._v("Homogeneous coordinates:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12  m13   0 ]   [ px ]  \n[ m21  m22  m23   0 ] * [ py ]  \n[ m31  m32  m33   0 ]   [ pz ]  \n[  0    0    0    1 ]   [ 1  ]\n")])])]),t("h2",{attrs:{id:"linear-transformations-in-3d-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d-2"}},[a._v("#")]),a._v(" Linear Transformations in 3D")]),a._v(" "),t("p",[t("strong",[a._v("Scaling (크기 조절):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("S_s = [ Sx  0   0 ]         S_s (in 4x4) = [ Sx  0   0   0 ]\n      [ 0  Sy   0 ]                           [ 0  Sy   0   0 ]\n      [ 0   0  Sz ]                           [ 0   0  Sz   0 ]\n                                              [ 0   0   0   1 ]\n")])])]),t("p",[t("strong",[a._v("Shear (in x, based on z position):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("H_xz_d = [ 1   0   d1 ]      H_xz_d (in 4x4) = [ 1   0   d1   0 ]\n         [ 0   1   0  ]                          [ 0   1    0   0 ]\n         [ 0   0   1  ]                          [ 0   0    1   0 ]\n                                                [ 0   0    0   1 ]\n")])])]),t("h2",{attrs:{id:"linear-transformations-in-3d-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d-3"}},[a._v("#")]),a._v(" Linear Transformations in 3D")]),a._v(" "),t("p",[t("strong",[a._v("Rotation about x-axis:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("R_x(θ) = [ 1      0         0     ]  \n         [ 0   cosθ   -sinθ ]  \n         [ 0   sinθ    cosθ ]\n")])])]),t("p",[t("strong",[a._v("Rotation about y-axis:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("R_y(θ) = [ cosθ   0   sinθ ]  \n         [   0     1     0  ]  \n         [ -sinθ  0   cosθ ]\n")])])]),t("p",[t("strong",[a._v("Rotation about z-axis:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("R_z(θ) = [ cosθ  -sinθ   0 ]  \n         [ sinθ   cosθ   0 ]  \n         [   0      0     1 ]\n")])])]),t("p",[a._v("(오른손 법칙에 따라 z축을 기준으로 위에서 아래로 보는 시점에서 반시계 방향 회전)")]),a._v(" "),t("h2",{attrs:{id:"review-of-translations-in-2d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#review-of-translations-in-2d"}},[a._v("#")]),a._v(" Review of Translations in 2D")]),a._v(" "),t("ul",[t("li",[a._v("2D에서의 Translation은 다음 두 방식으로 표현 가능:")])]),a._v(" "),t("p",[t("strong",[a._v("Vector addition (Cartesian coordinates):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ px ]   +   [ ux ]  \n[ py ]       [ uy ]\n")])])]),t("p",[t("strong",[a._v("Matrix multiplication (homogeneous coordinates):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ 1  0  ux ]   [ px ]  \n[ 0  1  uy ] * [ py ]  \n[ 0  0   1 ]   [ 1  ]\n")])])]),t("h2",{attrs:{id:"translations-in-3d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#translations-in-3d"}},[a._v("#")]),a._v(" Translations in 3D")]),a._v(" "),t("ul",[t("li",[a._v("3D에서의 Translation도 유사하게 표현 가능:")])]),a._v(" "),t("p",[t("strong",[a._v("Vector addition (Cartesian coordinates):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ px ]   +   [ ux ]  \n[ py ]       [ uy ]  \n[ pz ]       [ uz ]\n")])])]),t("p",[t("strong",[a._v("Matrix multiplication (homogeneous coordinates):")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ 1  0  0  ux ]   [ px ]  \n[ 0  1  0  uy ] * [ py ]  \n[ 0  0  1  uz ]   [ pz ]  \n[ 0  0  0   1 ]   [ 1  ]\n")])])]),t("h2",{attrs:{id:"review-of-affine-transformations-in-2d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#review-of-affine-transformations-in-2d"}},[a._v("#")]),a._v(" Review of Affine Transformations in 2D")]),a._v(" "),t("ul",[t("li",[a._v("Homogeneous coordinates에서는 2D affine transformation을"),t("br"),a._v("\n3×3 행렬 곱으로 표현할 수 있음:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12  ux ]   ← linear part | translational part\n[ m21  m22  uy ]  \n[  0    0    1 ]\n")])])]),t("h2",{attrs:{id:"affine-transformations-in-3d"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#affine-transformations-in-3d"}},[a._v("#")]),a._v(" Affine Transformations in 3D")]),a._v(" "),t("ul",[t("li",[a._v("Homogeneous coordinates에서는 3D affine transformation을"),t("br"),a._v("\n4×4 행렬 곱으로 표현할 수 있음:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("[ m11  m12  m13  ux ]   ← linear part | translational part\n[ m21  m22  m23  uy ]  \n[ m31  m32  m33  uz ]  \n[  0    0    0    1  ]\n")])])]),t("h2",{attrs:{id:"summary-affine-transformation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#summary-affine-transformation"}},[a._v("#")]),a._v(" Summary: Affine Transformation")]),a._v(" "),t("ul",[t("li",[a._v("p라는 점 집합에 대해 affine transformation M을 적용하면:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("p' = M * p\n\nM =\n[ m11  m12  m13  t1 ]  \n[ m21  m22  m23  t2 ]  \n[ m31  m32  m33  t3 ]  \n[  0    0    0    1 ]\n")])])]),t("ul",[t("li",[a._v("각 점마다 개별적으로 적용:")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("p₁′ = M * p₁  \np₂′ = M * p₂  \n...  \npₙ′ = M * pₙ\n")])])]),t("p",[a._v("(도식: 돌고래 mesh의 각 점에 transform 적용 예시)")]),a._v(" "),t("h2",{attrs:{id:"summary-composition-of-affine-transformations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#summary-composition-of-affine-transformations"}},[a._v("#")]),a._v(" Summary: Composition of Affine Transformations")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("여러 개의 affine transformation (예: M₁, M₂)을 순차적으로 적용할 수 있음")])]),a._v(" "),t("li",[t("p",[a._v("각 점마다:")])])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("p₁′ = M₂ * M₁ * p₁  \np₂′ = M₂ * M₁ * p₂  \n...  \npₙ′ = M₂ * M₁ * pₙ\n")])])]),t("p",[a._v("(도식: 돌고래 mesh에 두 변환을 순차 적용한 예시)")])])}),[],!1,null,null,null);t.default=r.exports}}]);
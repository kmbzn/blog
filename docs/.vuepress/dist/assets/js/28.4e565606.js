(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{351:function(i,r,e){"use strict";e.r(r);var a=e(30),t=Object(a.a)({},(function(){var i=this,r=i._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[r("h1",{attrs:{id:"_2-rendering-basics"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-rendering-basics"}},[i._v("#")]),i._v(" 2 - Rendering Basics")]),i._v(" "),r("h2",{attrs:{id:"summary-of-course-intro"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#summary-of-course-intro"}},[i._v("#")]),i._v(" Summary of Course Intro")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("Questions")]),i._v(" "),r("ul",[r("li",[i._v("https://www.slido.com/ - Join #cg-ys")])])]),i._v(" "),r("li",[r("p",[i._v("Quiz")]),i._v(" "),r("ul",[r("li",[i._v("https://www.slido.com/ - Join #cg-ys - Polls")]),i._v(" "),r("li",[i._v("퀴즈 답안은 정해진 형식으로 제출해야 출석으로 인정함")]),i._v(" "),r("li",[i._v("정답 여부는 출석과 무관함")])])]),i._v(" "),r("li",[r("p",[i._v("Language")]),i._v(" "),r("ul",[r("li",[i._v("대부분의 슬라이드는 한국어로 "),r("strong",[i._v("풀이(paraphrase)")]),i._v(" 제공")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v('"1 – Course Intro.pdf"를 반드시 정독할 것')])])])]),i._v(" "),r("h2",{attrs:{id:"outline-개요"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#outline-개요"}},[i._v("#")]),i._v(" Outline 개요")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("Rendering의 기본 개념")])]),i._v(" "),r("li",[r("p",[i._v("Rendering 방식")]),i._v(" "),r("ul",[r("li",[i._v("Rasterization 래스터화")]),i._v(" "),r("li",[i._v("Ray Tracing")])])])]),i._v(" "),r("h2",{attrs:{id:"basic-concepts-rendering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-rendering"}},[i._v("#")]),i._v(" Basic Concepts: Rendering")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Rendering은 컴퓨터 프로그램을 통해 2D 또는 3D 장면(scene)으로부터 이미지를 생성하는 과정")]),r("br"),i._v(" "),r("em",[i._v("(출처: Wikipedia)")])])]),i._v(" "),r("li",[r("p",[i._v("Rendering 결과물은 다음과 같이 저장 가능:")]),i._v(" "),r("ul",[r("li",[i._v("이미지 파일")]),i._v(" "),r("li",[i._v("영상 파일 (여러 이미지 프레임의 연속)")]),i._v(" "),r("li",[i._v("또는 "),r("strong",[i._v("frame buffer")]),i._v("에 저장되어 디스플레이에 출력")])])])]),i._v(" "),r("h2",{attrs:{id:"basic-concepts-frame-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-frame-buffer"}},[i._v("#")]),i._v(" Basic Concepts: Frame Buffer")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Frame buffer")]),i._v("는 raster 디스플레이 장치에 보낼 비트맵 이미지를 저장하는 메모리 영역")])]),i._v(" "),r("li",[r("p",[i._v("frame buffer는 다음과 같은 속성으로 정의됨:")]),i._v(" "),r("ul",[r("li",[i._v("가로, 세로, 깊이")]),i._v(" "),r("li",[i._v("예: 4K UHD (3840×2160) 해상도, 32bit 컬러 → 3840 × 2160 × 32 bits")])])]),i._v(" "),r("li",[r("p",[i._v("보통 "),r("strong",[i._v("그래픽 카드 메모리")]),i._v("에 저장됨")])])]),i._v(" "),r("h2",{attrs:{id:"basic-concepts-double-buffering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-double-buffering"}},[i._v("#")]),i._v(" Basic Concepts: Double Buffering")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("화면 출력과 렌더링을 위해 "),r("strong",[i._v("두 개의 frame buffer 사용")])]),i._v(" "),r("ul",[r("li",[i._v("새로운 이미지를 "),r("strong",[i._v("back buffer")]),i._v("에 그림")]),i._v(" "),r("li",[i._v("이전 이미지가 출력되는 동안 "),r("strong",[i._v("front buffer")]),i._v("를 유지")]),i._v(" "),r("li",[i._v("다음 프레임이 준비되면 두 버퍼를 "),r("strong",[i._v("스왑(swap)")])])])]),i._v(" "),r("li",[r("p",[i._v("→ "),r("strong",[i._v("프레임 속도 향상")]),i._v(", 또는 "),r("strong",[i._v("깜빡임(flickering) 감소")])])]),i._v(" "),r("li",[r("p",[i._v("대부분의 그래픽 애플리케이션은 "),r("strong",[i._v("double buffering 사용")])])])]),i._v(" "),r("h2",{attrs:{id:"basic-concepts-image-plane"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-image-plane"}},[i._v("#")]),i._v(" Basic Concepts: Image Plane")]),i._v(" "),r("ul",[r("li",[r("strong",[i._v("Image plane은 가상 3D 장면에서 렌더링된 이미지를 사용자가 보는 실제 디스플레이 화면을 개념적으로 나타내는 평면")])])]),i._v(" "),r("h2",{attrs:{id:"example-of-rendering-a-3d-scene"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#example-of-rendering-a-3d-scene"}},[i._v("#")]),i._v(" Example of Rendering a 3D Scene")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("3D Scene 예시 (이미지 참고)")]),i._v(" "),r("ul",[r("li",[i._v("Camera 위치에서 image plane을 통해 장면이 렌더링됨")])])]),i._v(" "),r("li",[r("p",[i._v("Rendering output 예시")]),i._v(" "),r("ul",[r("li",[i._v('(이 이미지는 Colin Behrens가 제작한 Blender 데모 장면 "Loro Mask"를 렌더링한 결과)')])])])]),i._v(" "),r("h2",{attrs:{id:"render-output"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-output"}},[i._v("#")]),i._v(" Render Output")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("렌더링 결과는 "),r("strong",[i._v("picture elements 또는 pixels")]),i._v("로 구성된 "),r("strong",[i._v("2D 이미지")])])]),i._v(" "),r("li",[r("p",[i._v("즉, 렌더링이란 "),r("strong",[i._v("3D 장면 정보에 기반하여 각 픽셀의 색상을 계산하는 과정")])])])]),i._v(" "),r("h2",{attrs:{id:"rendering-approaches"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rendering-approaches"}},[i._v("#")]),i._v(" Rendering Approaches")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("각 픽셀의 색상을 어떻게 계산할 것인가?")])]),i._v(" "),r("li",[r("p",[i._v("주요 접근 방식:")]),i._v(" "),r("ul",[r("li",[i._v("Rasterization")]),i._v(" "),r("li",[i._v("Ray Tracing")])])]),i._v(" "),r("li",[r("p",[i._v("학습 기반 장면 표현 방법:")]),i._v(" "),r("ul",[r("li",[r("strong",[i._v("NeRF")]),i._v(": 암시적 3D 장면 표현 학습")]),i._v(" "),r("li",[r("strong",[i._v("Gaussian Splatting")]),i._v(": 포인트 기반 3D 장면 표현 학습")])])])]),i._v(" "),r("h2",{attrs:{id:"rasterization"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization"}},[i._v("#")]),i._v(" Rasterization")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Primitive-by-primitive 방식")])]),i._v(" "),r("ul",[r("li",[i._v("primitive 예시: triangle, line, point 등")]),i._v(" "),r("li",[i._v("각 primitive는 이미지 내 어느 픽셀에 영향을 미치는지를 결정하고 해당 픽셀의 색을 설정함")])])])]),i._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[i._v("for each primitive in scene :\n    transform the primitive to viewport\n    find pixels for the primitive\n    set color of the pixels based on texture and lighting model\n")])])]),r("ul",[r("li",[i._v("예시: 삼각형 하나가 화면에 렌더링됨")])]),i._v(" "),r("h2",{attrs:{id:"rasterization-pipeline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-pipeline"}},[i._v("#")]),i._v(" Rasterization Pipeline")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("주요 단계:")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Vertex Processing")])]),i._v(" "),r("ul",[r("li",[i._v("vertex를 screen space로 변환")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Primitive Processing")])]),i._v(" "),r("ul",[r("li",[i._v("vertex들을 polygon으로 구성")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Scan Conversion")])]),i._v(" "),r("ul",[r("li",[i._v("polygon을 fragment 집합으로 변환")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Fragment Processing")])]),i._v(" "),r("ul",[r("li",[i._v("각 fragment의 색상 결정 (텍스처, 조명 모델 등 고려)")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Per-sample Operations")])]),i._v(" "),r("ul",[r("li",[i._v("depth test, alpha blending 등 수행")])])])])]),i._v(" "),r("li",[r("p",[i._v("흔히 "),r("strong",[i._v("rendering pipeline 또는 graphics pipeline")]),i._v("이라 부름")])])]),i._v(" "),r("h2",{attrs:{id:"rendering-pipeline-again"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rendering-pipeline-again"}},[i._v("#")]),i._v(" Rendering Pipeline again")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("입력: 각 오브젝트 공간의 vertex")])]),i._v(" "),r("li",[r("p",[i._v("처리 순서:")]),i._v(" "),r("ul",[r("li",[i._v("screen space의 vertex")]),i._v(" "),r("li",[i._v("screen space의 primitive")]),i._v(" "),r("li",[i._v("pixel당 하나 이상의 fragment")]),i._v(" "),r("li",[i._v("색상 계산된 shaded fragments")]),i._v(" "),r("li",[i._v("최종 출력: image")])])])]),i._v(" "),r("h2",{attrs:{id:"ray-tracing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ray-tracing"}},[i._v("#")]),i._v(" Ray Tracing")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Pixel-by-pixel 방식")])])]),i._v(" "),r("li",[r("p",[i._v("카메라 위치에서 image plane 상의 각 픽셀을 통과하는 ray를 생성")])]),i._v(" "),r("li",[r("p",[i._v("해당 ray가 어떤 오브젝트와 교차하는지에 따라 픽셀의 색상이 결정됨")])])]),i._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[i._v("for each pixel in image(plane)\n  determine which object should be shown at the pixel\n  set color of the pixel based on texture and lighting model\n")])])]),r("ul",[r("li",[i._v("예시: ray 교차 결과가 화면에 렌더링됨")])]),i._v(" "),r("h2",{attrs:{id:"ray-tracing-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ray-tracing-2"}},[i._v("#")]),i._v(" Ray Tracing")]),i._v(" "),r("ul",[r("li",[r("strong",[i._v("Ray tracing에 대한 자세한 설명은 다음 자료 참고")]),i._v(":\n"),r("ul",[r("li",[i._v('"Ray Tracing in One Weekend":'),r("br"),i._v("\nhttps://raytracing.github.io/books/RayTracingInOneWeekend.html")])])])]),i._v(" "),r("h2",{attrs:{id:"rasterization-vs-ray-tracing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-vs-ray-tracing"}},[i._v("#")]),i._v(" Rasterization vs. Ray Tracing")]),i._v(" "),r("ul",[r("li",[i._v("(이미지는 Nvidia에서 제공한 비교 시각화 자료)")])]),i._v(" "),r("h2",{attrs:{id:"rasterization-pros-cons"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-pros-cons"}},[i._v("#")]),i._v(" Rasterization – Pros & Cons")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("장점")])]),i._v(" "),r("ul",[r("li",[i._v("삼각형 스트림만 렌더링하면 되므로 전체 장면 데이터를 유지할 필요가 없음")]),i._v(" "),r("li",[i._v("병렬 처리에 적합 → "),r("strong",[i._v("빠름")])])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("단점")])]),i._v(" "),r("ul",[r("li",[i._v("그림자, 반사, 투명도에 대한 통일된 처리 방식이 없음")]),i._v(" "),r("li",[i._v("상대적으로 낮은 품질의 결과물")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("전통적으로 실시간 렌더링에 사용")])]),i._v(" "),r("ul",[r("li",[i._v("예: OpenGL 또는 DirectX 기반 게임")])])])]),i._v(" "),r("h2",{attrs:{id:"ray-tracing-pros-cons"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ray-tracing-pros-cons"}},[i._v("#")]),i._v(" Ray Tracing – Pros & Cons")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("장점")])]),i._v(" "),r("ul",[r("li",[i._v("그림자, 반사, 투명도 처리 등에서 통합된 방식 제공"),r("br"),i._v("\n→ Ray와의 교차로 처리됨")]),i._v(" "),r("li",[r("strong",[i._v("고품질 결과물 생성 가능")])])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("단점 (전통적 관점)")])]),i._v(" "),r("ul",[r("li",[i._v("실시간 응용에 너무 느림")]),i._v(" "),r("li",[i._v("하드웨어 구현이 어려움")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("전통적으로 영화용 오프라인 렌더링에 사용됨")])]),i._v(" "),r("ul",[r("li",[i._v("예: Maya, Blender 등의 3D 저작 툴을 사용한 애니메이션 영화")])])])]),i._v(" "),r("h2",{attrs:{id:"recent-ray-tracing-technology"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#recent-ray-tracing-technology"}},[i._v("#")]),i._v(" Recent Ray Tracing Technology")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("그러나 이 단점들은 더 이상 완전히 사실이 아님")]),i._v(" "),r("ul",[r("li",[i._v("Rasterization보다 느리지만, "),r("strong",[i._v("실시간도 가능할 만큼 충분히 빠름")])]),i._v(" "),r("li",[i._v("구현은 여전히 어렵지만, "),r("strong",[i._v("하드웨어가 뒷받침됨")])])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("지금은 다음과 같은 것들이 가능")]),i._v(":")]),i._v(" "),r("ul",[r("li",[i._v("Nvidia RTX 시리즈와 같은 하드웨어")]),i._v(" "),r("li",[i._v("DirectX Raytracing, Vulkan RT 등의 API")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("최근 변화된 흐름")])]),i._v(" "),r("ul",[r("li",[i._v("최초의 실시간 ray tracing 데모 “Reflections”는 "),r("strong",[i._v("2018년 3월 발표")]),i._v(" "),r("ul",[r("li",[i._v("https://youtu.be/JMtsYoYoCt3s")])])])])])]),i._v(" "),r("h2",{attrs:{id:"in-this-course"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in-this-course"}},[i._v("#")]),i._v(" In This Course,")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("강의는 "),r("strong",[i._v("모든 렌더링 방식에 공통되는")]),i._v(" computer graphics의 기본 개념에 초점을 맞춤")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("Movement & placement")]),i._v(":"),r("br"),i._v("\nTransformations, Hierarchical Modeling, Orientation & Rotation,"),r("br"),i._v("\nKinematics & Animation, Curves")])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Shape & appearance")]),i._v(":"),r("br"),i._v("\nMesh, Lighting, Texture Mapping, Curves")])])])])]),i._v(" "),r("h2",{attrs:{id:"in-this-course-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in-this-course-2"}},[i._v("#")]),i._v(" In This Course,")]),i._v(" "),r("ul",[r("li",[r("p",[i._v("일부 강의는 "),r("strong",[i._v("rasterization에 특화된 개념")]),i._v("도 다룸")]),i._v(" "),r("ul",[r("li",[r("p",[r("strong",[i._v("2D 화면으로의 매핑 과정")])]),i._v(" "),r("ul",[r("li",[i._v("Viewing / Projection / Viewport 변환")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("형상 표현")])]),i._v(" "),r("ul",[r("li",[i._v("Polygon shading")])])]),i._v(" "),r("li",[r("p",[r("strong",[i._v("Rasterization 처리 절차")])]),i._v(" "),r("ul",[r("li",[i._v("Rasterization pipeline, Scan Conversion, Visibility")])])])])]),i._v(" "),r("li",[r("p",[i._v("실습에서는 여전히 널리 쓰이는 "),r("strong",[i._v("modern OpenGL")]),i._v(" 사용")]),i._v(" "),r("ul",[r("li",[i._v("강의에서 배운 개념 복습용 도구로 사용됨")])])])]),i._v(" "),r("h2",{attrs:{id:"in-this-course-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in-this-course-3"}},[i._v("#")]),i._v(" In This Course,")]),i._v(" "),r("ul",[r("li",[i._v("이 수업에서는 "),r("strong",[i._v("ray tracing 또는 learnable scene representation을 다루지 않음")]),i._v(" "),r("ul",[r("li",[r("strong",[i._v("실시간 렌더링에서 rasterization은 여전히 중요")])]),i._v(" "),r("li",[i._v("커버할 시간이 부족함")])])])])])}),[],!1,null,null,null);r.default=t.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{351:function(t,a,r){"use strict";r.r(a);var _=r(30),e=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_4-affine-space-frame-matrix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-affine-space-frame-matrix"}},[t._v("#")]),t._v(" 4 - Affine Space / Frame / Matrix")]),t._v(" "),a("h2",{attrs:{id:"outline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[t._v("#")]),t._v(" Outline")]),t._v(" "),a("ul",[a("li",[t._v("Affine Space - Point vs. Vector")]),t._v(" "),a("li",[t._v("Coordinate System & Reference Frame")]),t._v(" "),a("li",[t._v("Affine Transformation Matrix")]),t._v(" "),a("li",[t._v("Interpretation of Composite Transformations")])]),t._v(" "),a("h2",{attrs:{id:"affine-space-point-vs-vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#affine-space-point-vs-vector"}},[t._v("#")]),t._v(" Affine Space - Point vs. Vector")]),t._v(" "),a("ul",[a("li",[t._v("개념적으로 "),a("strong",[t._v("point와 vector는 매우 다름")])]),t._v(" "),a("li",[t._v("이 차이는 "),a("strong",[t._v("homogeneous coordinates")]),t._v("로 표현할 수 있음")]),t._v(" "),a("li",[t._v("이 강의에서는 affine space, "),a("strong",[t._v("point와 vector의 차이점")]),t._v(", 그리고 그것이 homogeneous coordinates와 어떻게 연결되는지를 학습함")]),t._v(" "),a("li",[t._v("이 개념은 coordinate invariant 또는 coordinate-free geometric programming이라고도 불림")])]),t._v(" "),a("blockquote",[a("p",[a("em",[t._v("(출처: http://mrl.snu.ac.kr/courses/CourseGraphics/index_2017spring.html)")])])]),t._v(" "),a("h2",{attrs:{id:"points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#points"}},[t._v("#")]),t._v(" Points")]),t._v(" "),a("ul",[a("li",[t._v("Point $\\mathbf{p}$, Point $\\mathbf{q}$")]),t._v(" "),a("li",[t._v('이 두 점을 더한 "sum"은 무엇인가?')])]),t._v(" "),a("h2",{attrs:{id:"if-you-assume-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-you-assume-coordinates"}},[t._v("#")]),t._v(" If you assume coordinates, …")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{p} = (x_1,~y_1)$")]),t._v(" "),a("li",[t._v("$\\mathbf{q} = (x_2,~y_2)$")]),t._v(" "),a("li",[t._v("합: $(x_1+x_2,~y_1+y_2)$\n"),a("ul",[a("li",[t._v("이게 맞는가?")]),t._v(" "),a("li",[a("strong",[t._v("기하학적으로 의미")]),t._v("가 있는가?")])])]),t._v(" "),a("li",[t._v("동일한 좌표 표현에서,")]),t._v(" "),a("li",[t._v("$\\mathbf{p} = (x_1,~y_1)$")]),t._v(" "),a("li",[t._v("$\\mathbf{q} = (x_2,~y_2)$")]),t._v(" "),a("li",[t._v("$(x_1+x_2,~y_1+y_2)$는 단순한 합이 아닌,"),a("br"),t._v(" "),a("strong",[t._v("원점에서 $\\mathbf{p}$와 $\\mathbf{q}$까지 가는 vector의 합")]),t._v("으로 간주해야 함"),a("br"),t._v("\n→ "),a("strong",[t._v("Vector sum")])])]),t._v(" "),a("h2",{attrs:{id:"if-you-select-a-different-origin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-you-select-a-different-origin"}},[t._v("#")]),t._v(" If you select a different origin, …")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{p} = (x_1,~y_1)$")]),t._v(" "),a("li",[t._v("$\\mathbf{q} = (x_2,~y_2)$")]),t._v(" "),a("li",[t._v("$(x_1+x_2,~y_1+y_2)$의 의미는"),a("br"),t._v(" "),a("strong",[t._v("좌표계(원점)가 어디인지에 따라 달라짐")])]),t._v(" "),a("li",[t._v("즉, "),a("strong",[t._v("다른 coordinate frame을 선택하면 결과도 달라짐")])])]),t._v(" "),a("h2",{attrs:{id:"points-and-vectors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#points-and-vectors"}},[t._v("#")]),t._v(" Points and Vectors")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("point")]),t._v("는 좌표값으로 정의된 위치")]),t._v(" "),a("li",[a("strong",[t._v("vector")]),t._v("는 두 점 사이의 차이로 정의됨")]),t._v(" "),a("li",[t._v("원점이 정의되었다면, point는 원점에서 해당 point까지의 "),a("strong",[t._v("vector로 표현 가능")])]),t._v(" "),a("li",[t._v("하지만 coordinate-free 관점에서는 "),a("strong",[t._v("point는 vector가 아님")])])]),t._v(" "),a("h2",{attrs:{id:"points-vectors-are-different"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-are-different"}},[t._v("#")]),t._v(" Points & Vectors are Different!")]),t._v(" "),a("ul",[a("li",[t._v("수학적(또는 물리적)으로,\n"),a("ul",[a("li",[t._v("Point는 공간상의 "),a("strong",[t._v("위치")])]),t._v(" "),a("li",[t._v("Vector는 공간상의 "),a("strong",[t._v("변위")])])])]),t._v(" "),a("li",[t._v("시간에 비유하면 다음과 같음:\n"),a("ul",[a("li",[t._v("datetime은 시간의 "),a("strong",[t._v("위치")])]),t._v(" "),a("li",[t._v("duration은 시간의 "),a("strong",[t._v("변위")])])])])]),t._v(" "),a("h2",{attrs:{id:"vector-and-affine-spaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector-and-affine-spaces"}},[t._v("#")]),t._v(" Vector and Affine Spaces")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Vector space")]),t._v(" "),a("ul",[a("li",[t._v("벡터와 그 연산 포함")]),t._v(" "),a("li",[t._v("점(points)은 포함하지 않음")])])]),t._v(" "),a("li",[a("strong",[t._v("Affine space")]),t._v(" "),a("ul",[a("li",[t._v("vector space의 상위 개념")]),t._v(" "),a("li",[t._v("벡터, 점, 그에 관련된 연산 모두 포함")])])])]),t._v(" "),a("h2",{attrs:{id:"vector-spaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector-spaces"}},[t._v("#")]),t._v(" Vector spaces")]),t._v(" "),a("ul",[a("li",[t._v("A "),a("strong",[t._v("vector space")]),t._v("는 다음으로 구성됨:\n"),a("ul",[a("li",[t._v("벡터 집합과")]),t._v(" "),a("li",[t._v("두 가지 연산:\n"),a("ul",[a("li",[t._v("벡터 간 덧셈")]),t._v(" "),a("li",[t._v("스칼라 곱")])])])])])]),t._v(" "),a("h2",{attrs:{id:"linear-combination"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-combination"}},[t._v("#")]),t._v(" Linear Combination")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("벡터들의 선형 결합(linear combination)")]),t._v(" 또한 벡터임")])]),t._v(" "),a("p",[t._v("$$\n\\mathbf{u}_0, \\mathbf{u}_1, \\dots, \\mathbf{u}_n \\in V \\\\\n\\Rightarrow\nc_0 \\mathbf{u}_0 + c_1 \\mathbf{u}_1 + \\dots + c_n \\mathbf{u}_n \\in V\n$$")]),t._v(" "),a("h2",{attrs:{id:"affine-spaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#affine-spaces"}},[t._v("#")]),t._v(" Affine Spaces")]),t._v(" "),a("ul",[a("li",[t._v("An "),a("strong",[t._v("affine space")]),t._v("는 다음으로 구성됨:\n"),a("ul",[a("li",[t._v("점들의 집합, 관련된 벡터 공간")]),t._v(" "),a("li",[t._v("두 가지 연산:\n"),a("ul",[a("li",[t._v("두 점의 차이")]),t._v(" "),a("li",[t._v("점 + 벡터")])])])])])]),t._v(" "),a("h2",{attrs:{id:"coordinate-free-geometric-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-free-geometric-operations"}},[t._v("#")]),t._v(" Coordinate-Free Geometric Operations")]),t._v(" "),a("ul",[a("li",[t._v("덧셈 (Addition)")]),t._v(" "),a("li",[t._v("뺄셈 (Subtraction)")]),t._v(" "),a("li",[t._v("스칼라 곱 (Scalar multiplication)")])]),t._v(" "),a("h2",{attrs:{id:"addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#addition"}},[t._v("#")]),t._v(" Addition")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{u}, \\mathbf{v}, \\mathbf{w}$: vectors")]),t._v(" "),a("li",[t._v("$\\mathbf{p}, \\mathbf{q}$: points"),a("br"),t._v("\n라고 할 때,")]),t._v(" "),a("li",[t._v("$\\mathbf{u} + \\mathbf{v} \\rightarrow$ "),a("strong",[t._v("vector")])]),t._v(" "),a("li",[t._v("$\\mathbf{p} + \\mathbf{w} \\rightarrow$ "),a("strong",[t._v("point")])])]),t._v(" "),a("h2",{attrs:{id:"subtraction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#subtraction"}},[t._v("#")]),t._v(" Subtraction")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{u} - \\mathbf{v} \\rightarrow$ vector")]),t._v(" "),a("li",[t._v("$\\mathbf{p} - \\mathbf{q} \\rightarrow$ vector")]),t._v(" "),a("li",[t._v("$\\mathbf{p} - \\mathbf{w} \\rightarrow$ point")])]),t._v(" "),a("h2",{attrs:{id:"scalar-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scalar-multiplication"}},[t._v("#")]),t._v(" Scalar Multiplication")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("스칼라 ⋅ 벡터 = 벡터")]),t._v(" "),a("ul",[a("li",[t._v("$c \\cdot \\mathbf{v} \\rightarrow$ vector")])])]),t._v(" "),a("li",[a("strong",[t._v("$1 \\cdot$ point = point")])]),t._v(" "),a("li",[a("strong",[t._v("$0 \\cdot$ point = vector")])]),t._v(" "),a("li",[a("strong",[t._v("$c \\cdot$ point = (undefined) $~\\text{if} ~(c \\neq 0,~1)$")])])]),t._v(" "),a("h2",{attrs:{id:"affine-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#affine-frame"}},[t._v("#")]),t._v(" Affine Frame")]),t._v(" "),a("ul",[a("li",[t._v("A "),a("strong",[t._v("frame")]),t._v("은 다음으로 정의됨:\n"),a("ul",[a("li",[t._v("벡터들의 집합 $ \\{ \\mathbf{v}_i~| ~ i = 1, \\dots, N \\}$")]),t._v(" "),a("li",[t._v("기준점 $\\mathbf{o}$")])])]),t._v(" "),a("li",[t._v("벡터들의 집합 ${\\mathbf{v}_i}$는 해당 vector space의 "),a("strong",[t._v("bases")])]),t._v(" "),a("li",[t._v("$\\mathbf{o}$는 해당 frame의 "),a("strong",[t._v("origin")])]),t._v(" "),a("li",[t._v("$N$은 affine space의 **dimension **")]),t._v(" "),a("li",[t._v("임의의 점 $\\mathbf{p}$는 다음과 같이 표현됨:\n$$\n\\mathbf{p} = \\mathbf{o} + c_1 \\mathbf{v}_1 + c_2 \\mathbf{v}_2 + \\dots + c_n \\mathbf{v}_n\n$$")]),t._v(" "),a("li",[t._v("임의의 벡터 $\\mathbf{v}$는 다음과 같이 표현됨:\n$$\n\\mathbf{v} = c_1 \\mathbf{v}_1 + c_2 \\mathbf{v}_2 + \\dots + c_n \\mathbf{v}_n\n$$")])]),t._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[t._v("#")]),t._v(" Summary")]),t._v(" "),a("ul",[a("li",[t._v("Affine space에서:\n$$\n\\begin{aligned}\n\\mathbf{p} + \\mathbf{p} & = \\text{(undefined)} \\\\\n\\mathbf{p} - \\mathbf{p} & = \\text{vector} \\\\\n\\mathbf{p} \\pm \\mathbf{v} & = \\text{point} \\\\\n\\mathbf{v} \\pm \\mathbf{v} & = \\text{vector} \\\\\nc \\cdot \\mathbf{v} & = \\text{vector} \\\\\n1 \\cdot \\mathbf{p} & = \\text{point} \\\\\n0 \\cdot \\mathbf{p} & = \\text{vector} \\\\\nc \\cdot \\mathbf{p} & = \\text{(undefined)} \\quad (c \\neq 0, 1)\n\\end{aligned}\n$$")])]),t._v(" "),a("h2",{attrs:{id:"points-vectors-in-homogeneous-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#points-vectors-in-homogeneous-coordinates"}},[t._v("#")]),t._v(" Points & Vectors in Homogeneous Coordinates")]),t._v(" "),a("ul",[a("li",[t._v("Homogeneous coordinates에서는,\n"),a("ul",[a("li",[a("strong",[t._v("3D point")]),t._v(": $ (x, y, z, \\mathbf{1}) $")]),t._v(" "),a("li",[a("strong",[t._v("3D vector")]),t._v(": $ (x, y, z, \\mathbf{0}) $")])])])]),t._v(" "),a("p",[t._v("→ 이 표현은 coordinate-free geometric programming의 개념과 "),a("strong",[t._v("완전하게 일치하는 모델")]),t._v("을 제공함")]),t._v(" "),a("p",[t._v("예시:\n$$\n(x_1, y_1, z_1, 1) + (x_2, y_2, z_2, 1) \\\\= (x_1 + x_2, y_1 + y_2, z_1 + z_2, 2) \\text{→ point (undefined)}\n$$")]),t._v(" "),a("p",[t._v("$$\n(x_1, y_1, z_1, 1) - (x_2, y_2, z_2, 1) \\\\= (x_1 - x_2, y_1 - y_2, z_1 - z_2, 0) \\text{→ vector}\n$$")]),t._v(" "),a("p",[t._v("$$\n(x_1, y_1, z_1, 1) + (x_2, y_2, z_2, 0) \\\\= (x_1 + x_2, y_1 + y_2, z_1 + z_2, 1) \\text{→ point}\n$$")]),t._v(" "),a("p",[t._v("$$\n(x_1, y_1, z_1, 0) + (x_2, y_2, z_2, 0) \\\\= (x_1 + x_2, y_1 + y_2, z_1 + z_2, 0) \\text{→ vector}\n$$")]),t._v(" "),a("p",[t._v("$$\nc \\cdot (x, y, z, 0) \\\\= (cx, cy, cz, 0) \\text{→ vector}\n$$")]),t._v(" "),a("p",[t._v("$$\nc \\cdot (x, y, z, 1) \\\\= (cx, cy, cz, c) \\text{→}\n\\begin{cases}\n\\text{point} & \\text{if } c = 1 \\\\\n\\text{vector} & \\text{if } c = 0 \\\\\n\\text{undefined} & \\text{if } c \\ne 0, 1\n\\end{cases}\n$$")]),t._v(" "),a("ul",[a("li",[t._v("Affine transformation matrix와 point, vector의 곱:")])]),t._v(" "),a("p",[t._v("$$\n\\begin{bmatrix}\n\\mathbf{M} & \\mathbf{t} \\\\\n\\mathbf{0}^\\mathrm{T} & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n1\n\\end{bmatrix} =\n\\begin{bmatrix}\n\\mathbf{M} \\mathbf{p} + \\mathbf{t} \\\\\n1\n\\end{bmatrix}\n\\text{→ point}\n$$")]),t._v(" "),a("p",[t._v("$$\n\\begin{bmatrix}\n\\mathbf{M} & \\mathbf{t} \\\\\n\\mathbf{0}^\\mathrm{T} & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{v} \\\\\n0\n\\end{bmatrix} =\n\\begin{bmatrix}\n\\mathbf{M} \\mathbf{v} \\\\\n0\n\\end{bmatrix}\n\\text{→ vector}\n$$")]),t._v(" "),a("p",[t._v("→ "),a("strong",[t._v("translation은 vector에는 적용되지 않음!")])]),t._v(" "),a("h2",{attrs:{id:"quiz-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quiz-1"}},[t._v("#")]),t._v(" Quiz 1")]),t._v(" "),a("h2",{attrs:{id:"coordinate-system-reference-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coordinate-system-reference-frame"}},[t._v("#")]),t._v(" Coordinate System & Reference Frame")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("Coordinate system")])]),t._v(" "),a("ul",[a("li",[t._v("점의 위치를 고유하게 결정하기 위해 하나 이상의 숫자 또는 좌표를 사용하는 체계")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Reference frame")])]),t._v(" "),a("ul",[a("li",[t._v("추상적인 좌표계 + 실제 기준점")]),t._v(" "),a("li",[t._v("좌표계를 고정시키기 위해 사용됨")])])]),t._v(" "),a("li",[a("p",[t._v("이 두 용어는 종종 혼용되지만, "),a("strong",[t._v("의미에는 약간의 차이")]),t._v("가 있음")])])]),t._v(" "),a("h2",{attrs:{id:"world-body-frame-or-coordinate-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#world-body-frame-or-coordinate-system"}},[t._v("#")]),t._v(" World / Body Frame (or Coordinate System)")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("World frame (or coordinate system)")])]),t._v(" "),a("ul",[a("li",[t._v("세계에 고정된 좌표계")]),t._v(" "),a("li",[t._v("aka. global frame, fixed frame")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Body frame (or coordinate system)")])]),t._v(" "),a("ul",[a("li",[t._v("물체에 고정된 좌표계")]),t._v(" "),a("li",[t._v("aka. local frame")])])])]),t._v(" "),a("h2",{attrs:{id:"meanings-of-affine-transformation-matrix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#meanings-of-affine-transformation-matrix"}},[t._v("#")]),t._v(" Meanings of Affine Transformation Matrix")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("하나의 affine transformation matrix")]),t._v("는"),a("br"),t._v(" "),a("strong",[t._v("여러 관점에서 해석 가능함")])])]),t._v(" "),a("h2",{attrs:{id:"_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-affine-transformation-matrix-transforms-a-geometry-w-r-t-world-frame"}},[t._v("#")]),t._v(" 1) Affine Transformation Matrix Transforms a Geometry w.r.t. World Frame")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("행렬 $\\mathbf{M}$은 "),a("strong",[t._v("기하 객체의 각 vertex 위치를 world frame 기준에서 새로운 위치로 변환")])])]),t._v(" "),a("li",[a("p",[t._v("변환 포함: translate, rotate, scale 등")])])]),t._v(" "),a("p",[t._v("$$\n\\mathbf{M} =\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} & u_x \\\\\nm_{21} & m_{22} & m_{23} & u_y \\\\\nm_{31} & m_{32} & m_{33} & u_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{M}$을 곱하면 geometry가 "),a("strong",[t._v("world frame에서 다른 위치로 이동된 결과")]),t._v("를 얻게 됨")])]),t._v(" "),a("h2",{attrs:{id:"review-affine-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#review-affine-frame"}},[t._v("#")]),t._v(" Review: Affine Frame")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("Affine frame")]),t._v(" (3D 공간 기준)은 다음으로 정의됨:\n"),a("ul",[a("li",[t._v("$x,~y,~z$축을 나타내는 "),a("strong",[t._v("3개의 벡터")])]),t._v(" "),a("li",[a("strong",[t._v("1개의 원점 위치(좌표)")])])])])]),t._v(" "),a("h2",{attrs:{id:"world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#world-frame"}},[t._v("#")]),t._v(" World Frame")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("World frame")]),t._v("은 보통 다음으로 표현됨:\n"),a("ul",[a("li",[t._v("표준 축 벡터"),a("br"),t._v("\n$$\n\\hat{\\mathbf{e}}_x = \\begin{bmatrix}1 \\\\ 0 \\\\ 0\\end{bmatrix}~\n\\hat{\\mathbf{e}}_y = \\begin{bmatrix}0 \\\\ 1 \\\\ 0\\end{bmatrix}~\n\\hat{\\mathbf{e}}_z = \\begin{bmatrix}0 \\\\ 0 \\\\ 1\\end{bmatrix}\n$$")]),t._v(" "),a("li",[t._v("원점"),a("br"),t._v("\n$$\n\\mathbf{0}= \\begin{bmatrix}0 \\\\ 0 \\\\ 0\\end{bmatrix}\n$$")])])])]),t._v(" "),a("h2",{attrs:{id:"let-s-transform-a-world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-s-transform-a-world-frame"}},[t._v("#")]),t._v(' Let’s Transform a "World Frame"')]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{M}$을 "),a("strong",[t._v("world frame에 곱하면")]),t._v(", 각 축 벡터 및 원점이 변환됨:")])]),t._v(" "),a("p",[t._v("$\n\\text{x-axis:} \\quad \\mathbf{M} \\begin{bmatrix}1 \\\\ 0 \\\\ 0 \\\\ 0\\end{bmatrix}\n$\n: 첫 번째 column")]),t._v(" "),a("p",[t._v("$\n\\text{y-axis:} \\quad \\mathbf{M} \\begin{bmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{bmatrix}\n$\n: 두 번째 column")]),t._v(" "),a("p",[t._v("$\n\\text{z-axis:} \\quad \\mathbf{M} \\begin{bmatrix}0 \\\\ 0 \\\\ 1 \\\\ 0\\end{bmatrix}\n$\n: 세 번째 column")]),t._v(" "),a("p",[t._v("$\n\\text{origin:} \\quad \\mathbf{M} \\begin{bmatrix}0 \\\\ 0 \\\\ 0 \\\\ 1\\end{bmatrix}\n$\n: 네 번째 column")]),t._v(" "),a("h2",{attrs:{id:"_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-affine-transformation-matrix-defines-an-affine-frame-w-r-t-world-frame"}},[t._v("#")]),t._v(" 2) Affine Transformation Matrix Defines an Affine Frame w.r.t. World Frame")]),t._v(" "),a("ul",[a("li",[t._v("행렬 $\\mathbf{M}$은 "),a("strong",[t._v("기준 프레임 $\\{0\\}$ 기준으로 표현된 body frame $\\{1\\}$을 정의")])]),t._v(" "),a("li",[t._v("$\\mathbf{M}$의 각 column은 다음을 나타냄:\n"),a("ul",[a("li",[t._v("앞의 3개 column: 축 벡터")]),t._v(" "),a("li",[t._v("마지막 column: 원점 위치")])])])]),t._v(" "),a("p",[t._v("→ $\\mathbf{M}$은 "),a("strong",[t._v("body frame $\\{1\\}$을 world frame $\\{0\\}$ 기준으로 표현")]),t._v("한 것")]),t._v(" "),a("h2",{attrs:{id:"examples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),a("ul",[a("li",[t._v("같은 물체의 body frame을 두 방식으로 정의:\n"),a("ol",[a("li",[t._v("world frame과 동일한 위치일 때")]),t._v(" "),a("li",[t._v("이동된 위치에서 정의될 때")])])])]),t._v(" "),a("p",[t._v("→ 두 경우 모두 $\\mathbf{M}$은 body frame을 world 기준으로 표현함")]),t._v(" "),a("h2",{attrs:{id:"_3-affine-transformation-matrix-transforms-a-point-in-body-frame-to-the-same-point-but-represented-in-world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-affine-transformation-matrix-transforms-a-point-in-body-frame-to-the-same-point-but-represented-in-world-frame"}},[t._v("#")]),t._v(" 3) Affine Transformation Matrix Transforms a Point in Body Frame to (the same) Point (but) represented in World Frame")]),t._v(" "),a("ul",[a("li",[t._v("$ \\mathbf{p}^{\\{1\\}} = \\begin{bmatrix}1 \\\\ 1 \\\\ 0\\end{bmatrix} $"),a("br"),t._v("\n(body frame $\\{1\\}$ 기준의 점)\n$$\n\\mathbf{p}^{\\{0\\}} = \\mathbf{M} \\cdot \\mathbf{p}^{\\{1\\}}\n$$")]),t._v(" "),a("li",[t._v("같은 점을 "),a("strong",[t._v("world frame $\\{0\\}$ 기준으로 표현한 것")]),a("br"),t._v("\nWhy?")]),t._v(" "),a("li",[t._v("동일한 물체를 body frame에서 보다가 $\\mathbf{M}$을 통해 "),a("strong",[t._v("world frame 기준 표현")]),t._v("으로 변환한 것:\n$$\n\\mathbf{p}^{\\{0\\}} = \\mathbf{M} \\cdot \\mathbf{p}^{\\{1\\}}\n$$")]),t._v(" "),a("li",[t._v("단순히 geometry를 변환한 이야기임")])]),t._v(" "),a("h2",{attrs:{id:"directions-of-the-arrow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#directions-of-the-arrow"}},[t._v("#")]),t._v(' Directions of the "arrow"')]),t._v(" "),a("ul",[a("li",[t._v("첫 번째 의미\n"),a("ul",[a("li",[t._v("geometry 자체를 transform (frame은 그대로)")]),t._v(" "),a("li",[t._v("$\\mathbf{M}$은 변환의 방향을 나타냄: ${\\{0\\}}\\rightarrow{\\{1\\}}$"),a("br"),t._v("\n→ $\\mathbf{p}^{\\{0\\}}$가 변환되어 $\\mathbf{p}^{\\{1\\}}$이 됨.")])])]),t._v(" "),a("li",[t._v("두 번째 의미\n"),a("ul",[a("li",[t._v("frame 자체의 변환")]),t._v(" "),a("li",[t._v("${\\{1\\}}$ 프레임이 ${\\{0\\}}$ 기준으로 어떻게 보이는지를 나타냄")])])]),t._v(" "),a("li",[t._v("세 번째 의미\n"),a("ul",[a("li",[t._v("$\\mathbf{p}$라는 점이 표현되는 "),a("strong",[t._v("프레임 자체")]),t._v('를 바꾸는 과정\n→ "표현의 기준"이 바뀜: $\\{0\\}$에서 본 $\\mathbf{p}$를 $\\{1\\}$에서 본 $\\mathbf{p}$로 변환하는 것')])])])]),t._v(" "),a("h2",{attrs:{id:"quiz-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quiz-2"}},[t._v("#")]),t._v(" Quiz 2")]),t._v(" "),a("h2",{attrs:{id:"all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#all-these-concepts-work-even-if-the-starting-frame-is-not-world-frame"}},[t._v("#")]),t._v(" All these concepts work even if the starting frame is not world frame!")]),t._v(" "),a("ul",[a("li",[t._v("시작 프레임이 world frame이 아니어도, 지금까지의 모든 개념은 그대로 적용 가능")])]),t._v(" "),a("h2",{attrs:{id:"_0-to-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-to-1"}},[t._v("#")]),t._v(" {0} to {1}")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{M}_1$은 다음을 수행:\n"),a("ol",[a("li",[t._v("프레임 $\\{0\\}$ 기준에서 geometry를 변환")]),t._v(" "),a("li",[t._v("프레임 $\\{0\\}$ 기준에서 프레임 $\\{1\\}$을 정의")]),t._v(" "),a("li",[t._v("프레임 $\\{1\\}$ 기준의 점을 $\\{0\\}$ 기준으로 표현"),a("br"),t._v("\n$$ \\mathbf{p}^{\\{0\\}} = \\mathbf{M}_1 \\cdot \\mathbf{p}^{\\{1\\}} $$")])])])]),t._v(" "),a("h2",{attrs:{id:"_1-to-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-to-2"}},[t._v("#")]),t._v(" {1} to {2}")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{M}_2$는 다음을 수행:\n"),a("ol",[a("li",[t._v("프레임 $\\{1\\}$ 기준에서 geometry를 변환")]),t._v(" "),a("li",[t._v("프레임 $\\{1\\}$ 기준에서 프레임 를 정의")]),t._v(" "),a("li",[t._v("프레임 $\\{2\\}$ 기준의 점을 $\\{1\\}$ 기준으로 표현"),a("br"),t._v("\n$$ \\mathbf{p}^{\\{1\\}} = \\mathbf{M}_2 \\cdot \\mathbf{p}^{\\{2\\}} $$")])])])]),t._v(" "),a("h2",{attrs:{id:"_0-to-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-to-2"}},[t._v("#")]),t._v(" {0} to {2}")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{M}_1 \\mathbf{M}_2$는 다음을 수행:\n"),a("ol",[a("li",[t._v("프레임 $\\{0\\}$ 기준에서 geometry를 변환")]),t._v(" "),a("li",[t._v("프레임 $\\{0\\}$ 기준에서 프레임 $\\{2\\}$를 정의")]),t._v(" "),a("li",[t._v("프레임 $\\{2\\}$ 기준의 점을 $\\{0\\}$ 기준으로 표현"),a("br"),t._v("\n$$ \\mathbf{p}^{\\{0\\}} = \\mathbf{M}_1 \\cdot \\mathbf{M}_2 \\cdot \\mathbf{p}^{\\{2\\}} $$")])])])]),t._v(" "),a("h2",{attrs:{id:"revisit-order-matters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#revisit-order-matters"}},[t._v("#")]),t._v(" Revisit: Order Matters!")]),t._v(" "),a("ul",[a("li",[t._v("$\\mathbf{T}, \\mathbf{R}$이 affine transformation을 나타내는 행렬일 때:\n$$\n\\mathbf{p}' = \\mathbf{T} \\cdot \\mathbf{R} \\cdot \\mathbf{p}\n\\\\\\Rightarrow \\text{ 먼저 } \\mathbf{R}(\\mathbf{p}) \\text{ 적용, 그 후 } \\mathbf{T}\n$$\n$$\n\\mathbf{p}' = \\mathbf{R} \\cdot \\mathbf{T} \\cdot \\mathbf{p}\n\\\\\\Rightarrow \\text{ 먼저 } \\mathbf{T}(\\mathbf{p}) \\text{ 적용, 그 후 } \\mathbf{R}\n$$")]),t._v(" "),a("li",[t._v("→ "),a("strong",[t._v("행렬의 곱셈 순서는 매우 중요함!")]),t._v(" "),a("ul",[a("li",[t._v("결합법칙은 성립하지만 교환법칙은 성립하지 않음: $AB \\ne BA$")])])])]),t._v(" "),a("h2",{attrs:{id:"composite-복합-transformations의-interpretation-해석"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composite-복합-transformations의-interpretation-해석"}},[t._v("#")]),t._v(" Composite(복합) Transformations의 Interpretation(해석)")]),t._v(" "),a("ul",[a("li",[t._v("예시 transformation:"),a("br"),t._v("\n$$ \\mathbf{M} = \\mathbf{T}(x,~3) \\cdot \\mathbf{R}(-90^\\circ) $$")]),t._v(" "),a("li",[t._v("지금까지 해석했던 방식:\n"),a("ul",[a("li",[a("strong",[t._v("$\\mathbf{R} \\rightarrow \\mathbf{T}$ 순서로")]),t._v(" 적용")]),t._v(" "),a("li",[t._v("$\\mathbf{R}$은 "),a("strong",[t._v("world frame 기준 변환")]),t._v("\n$$\n\\mathbf{p}\n\\xrightarrow{\\mathbf{R}(-90^\\circ)}\n\\mathbf{R}(\\mathbf{p})\n\\\\\\xrightarrow{\\mathbf{T}(x, 3)}\n\\mathbf{p}' = \\mathbf{T}(\\mathbf{R}(\\mathbf{p}))\n$$")])])]),t._v(" "),a("li",[a("strong",[t._v("다른 해석 방식")]),t._v(":\n"),a("ul",[a("li",[t._v("$\\mathbf{R} \\rightarrow \\mathbf{T}$ 순서가 아닌, "),a("strong",[t._v("$\\mathbf{T} \\rightarrow \\mathbf{R}$")]),t._v(" 순서로 해석")]),t._v(" "),a("li",[t._v("즉, "),a("strong",[t._v("body frame 기준")]),t._v("에서 해석하는 방식\n$$\n\\mathbf{p} \\rightarrow \\mathbf{T}(\\mathbf{p}) \\rightarrow \\mathbf{R}(\\mathbf{T}(\\mathbf{p})) = \\mathbf{M}(\\mathbf{p}) = \\mathbf{p}'\n$$\n→ 동일한 행렬이라도 "),a("strong",[t._v("기준 프레임에 따라 해석이 달라질 수 있음")])])])])]),t._v(" "),a("h2",{attrs:{id:"pre-left-post-right-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pre-left-post-right-multiplication"}},[t._v("#")]),t._v(" Pre-(left) & Post-(right) Multiplication")]),t._v(" "),a("h3",{attrs:{id:"pre-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pre-multiplication"}},[t._v("#")]),t._v(" Pre-multiplication:")]),t._v(" "),a("p",[t._v("$$\n\\mathbf{p}' = \\mathbf{M}_1 \\cdot \\mathbf{M}_2 \\cdot \\mathbf{p}\n\\\\ (\\text{pre-multiplication by } \\mathbf{M}_1)\n$$")]),t._v(" "),a("p",[t._v("→ "),a("strong",[t._v("Right-to-Left 순서")])]),t._v(" "),a("ol",[a("li",[t._v("$\\mathbf{M}_2$를 "),a("strong",[t._v("world frame 기준")]),t._v("으로 적용하여 $\\mathbf{p}$를 변환")]),t._v(" "),a("li",[t._v("그 결과에 $\\mathbf{M}_1$을 다시 "),a("strong",[t._v("world frame 기준")]),t._v("으로 적용")])]),t._v(" "),a("p",[t._v("→ 전체 변환은 $\\mathbf{M}_1 \\mathbf{M}_2$")]),t._v(" "),a("h3",{attrs:{id:"post-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#post-multiplication"}},[t._v("#")]),t._v(" Post-multiplication:")]),t._v(" "),a("p",[t._v("$$\n\\mathbf{p}' = \\mathbf{M}_1 \\cdot \\mathbf{M}_2 \\cdot \\mathbf{p}\n\\\\ (\\text{post-multiplication by } \\mathbf{M}_1)\n$$")]),t._v(" "),a("p",[t._v("→ "),a("strong",[t._v("Left-to-Right 순서")])]),t._v(" "),a("ol",[a("li",[t._v("$\\mathbf{p}$는 body frame $\\{1\\}$ 기준에서 표현되어 있음")]),t._v(" "),a("li",[t._v("$\\mathbf{M}_1$은 "),a("strong",[t._v("body frame $\\{1\\}$을 world frame 기준으로 업데이트")]),t._v("함")]),t._v(" "),a("li",[t._v("$\\mathbf{M}_2$는 이어서 "),a("strong",[t._v("body frame $\\{2\\}$로 업데이트")]),t._v("함")]),t._v(" "),a("li",[t._v("결과적으로 $\\mathbf{p}$는 body frame $\\{2\\}$ 기준에서 표현됨")])]),t._v(" "),a("p",[t._v("→ 전체 변환은 여전히 $\\mathbf{M}_1 \\mathbf{M}_2$")]),t._v(" "),a("h2",{attrs:{id:"또-다른-유용한-해석법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#또-다른-유용한-해석법"}},[t._v("#")]),t._v(" 또 다른 유용한 해석법")]),t._v(" "),a("ol",[a("li",[t._v("$\\mathbf{M}_1$: world frame 기준으로 적용하여 "),a("strong",[t._v("body frame을 $\\mathbf{M}_1$으로 업데이트")])]),t._v(" "),a("li",[t._v("$\\mathbf{M}_2$: 다시 world frame 기준으로 적용하여 "),a("strong",[t._v("body frame을 $\\mathbf{M}_1 \\mathbf{M}_2$로 업데이트")])]),t._v(" "),a("li",[t._v("$\\mathbf{p}$를 "),a("strong",[t._v("새로운 body frame $\\mathbf{M}_1 \\mathbf{M}_2$ 기준으로")]),t._v(" 위치시킴")])]),t._v(" "),a("h2",{attrs:{id:"demo-l-to-r-r-to-l-interpretation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo-l-to-r-r-to-l-interpretation"}},[t._v("#")]),t._v(" [Demo] L-to-R & R-to-L Interpretation")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://observablehq.com/@esperanc/transformation-demo",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://observablehq.com/@esperanc/transformation-demo"),a("OutboundLink")],1)]),t._v(" "),a("ul",[a("li",[t._v("다양한 순서로 translation 및 선형 변환 추가 ( '+' 버튼 사용)")]),t._v(" "),a("li",[t._v("슬라이더를 드래그하여 행렬 값의 변화 및 도형의 변화를 관찰")]),t._v(" "),a("li",[t._v("합성 변환의 의미를 "),a("strong",[t._v("L-to-R")]),t._v(", "),a("strong",[t._v("R-to-L")]),t._v(" 순서로 해석해보세요")])]),t._v(" "),a("home")],1)}),[],!1,null,null,null);a.default=e.exports}}]);
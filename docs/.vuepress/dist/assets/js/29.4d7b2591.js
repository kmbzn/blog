(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{350:function(n,a,t){"use strict";t.r(a);var i=t(30),r=Object(i.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"_3-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-transformations"}},[n._v("#")]),n._v(" 3 - Transformations")]),n._v(" "),a("h2",{attrs:{id:"outline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[n._v("#")]),n._v(" Outline")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("2차원 변환")]),n._v(" "),a("ul",[a("li",[n._v("Scaling, Rotation, Shearing, Reflection")]),n._v(" "),a("li",[n._v("Translation")])])]),n._v(" "),a("li",[a("p",[n._v("변환의 종류")])]),n._v(" "),a("li",[a("p",[n._v("변환의 합성과 Homogeneous Coordinates")])]),n._v(" "),a("li",[a("p",[n._v("두 가지 3차원 직교 좌표계")])]),n._v(" "),a("li",[a("p",[n._v("3차원 Affine 변환")])])]),n._v(" "),a("h2",{attrs:{id:"what-is-transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-transformation"}},[n._v("#")]),n._v(" What is Transformation?")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("Geometric "),a("strong",[n._v("Transformation")])]),n._v(" "),a("ul",[a("li",[a("p",[n._v("기하학적 object의 위치, 방향, 크기 또는 형태를 수학적으로 변경하는 과정"),a("br"),n._v("\n→ “점들의 집합을 이동시키는 것”")])]),n._v(" "),a("li",[a("p",[n._v("복잡한 장면과 애니메이션 생성을 가능하게 함")])]),n._v(" "),a("li",[a("p",[n._v("Computer graphics에서 필수적임")])])])]),n._v(" "),a("li",[a("p",[n._v("예시:")]),n._v(" "),a("ul",[a("li",[n._v("Translate")]),n._v(" "),a("li",[n._v("Rotate")]),n._v(" "),a("li",[n._v("Scale")]),n._v(" "),a("li",[n._v("Shear")]),n._v(" "),a("li",[n._v("Reflect")])])])]),n._v(" "),a("h2",{attrs:{id:"transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transformation"}},[n._v("#")]),n._v(" Transformation")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("“점들의 집합을 이동시키는 것”")])]),n._v(" "),a("li",[a("p",[n._v("Transformation T는 벡터 공간 S에 있는 임의의 입력 벡터 v를 T(v)로 사상(寫像)함")]),n._v(" "),a("p",[n._v("수식 표현: $S \\rightarrow \\{~ T(v) \\mid v \\in S ~\\}$")])])]),n._v(" "),a("h2",{attrs:{id:"linear-transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformation"}},[n._v("#")]),n._v(" Linear Transformation")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("행렬 곱을 통해 Transformation을 정의할 수 있음")]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{v}) = M\\mathbf{v}\n$$")])]),n._v(" "),a("li",[a("p",[n._v("이는 행렬 곱셈이 선형 사상(寫像)을 나타내게 되므로"),a("br"),n._v(" "),a("strong",[n._v("linear transformation")]),n._v("이라 부름")])]),n._v(" "),a("li",[a("p",[n._v("Linear transformation은 다음 조건을 만족해야 함:")]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{v}_1 + \\mathbf{v}_2) \\\\ = T(\\mathbf{v}_1) + T(\\mathbf{v}_2), \\quad T(c\\mathbf{v}) \\\\ = cT(\\mathbf{v})\n$$")])]),n._v(" "),a("li",[a("p",[n._v("행렬 $M$ 또한 동일한 *선형성(linearity)*을 만족:")]),n._v(" "),a("p",[n._v("$$\nM(\\mathbf{v}_1 + \\mathbf{v}_2) \\\\ = M\\mathbf{v}_1 + M\\mathbf{v}_2, \\quad M(c\\mathbf{v}) \\\\ = c(M\\mathbf{v})\n$$")])])]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-transformations"}},[n._v("#")]),n._v(" 2D Linear Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("2×2 행렬은 다음과 같은 2차원 linear transformation을 표현할 수 있음:")]),n._v(" "),a("ul",[a("li",[n._v("uniform scaling")]),n._v(" "),a("li",[n._v("non-uniform scaling")]),n._v(" "),a("li",[n._v("rotation")]),n._v(" "),a("li",[n._v("shearing")]),n._v(" "),a("li",[n._v("reflection")])])])]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-trans-uniform-scaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-uniform-scaling"}},[n._v("#")]),n._v(" 2D Linear Trans. – Uniform Scaling")]),n._v(" "),a("ul",[a("li",[n._v("x축과 y축 모두에서 동일한 비율로 확대 또는 축소")])]),n._v(" "),a("p",[n._v("$$\n\\mathbf{S} =\n\\begin{bmatrix}\ns & 0 \\\\\n0 & s\n\\end{bmatrix} \\\\"),a("br"),n._v("\n\\quad\n\\mathbf{p} =\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\\quad\\Rightarrow\\quad\n\\mathbf{p}' =\n\\begin{bmatrix}\nsx \\\\\nsy\n\\end{bmatrix}\n$$")]),n._v(" "),a("ul",[a("li",[n._v("예: 배율 ( s = 1.5 )인 scaling을 적용할 경우,")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n1.5 & 0 \\\\\n0 & 1.5\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix} =\n\\begin{bmatrix}\n1.5x \\\\\n1.5y\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-trans-nonuniform-scaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-nonuniform-scaling"}},[n._v("#")]),n._v(" 2D Linear Trans. – Nonuniform Scaling")]),n._v(" "),a("ul",[a("li",[n._v("$x$축과 $y$축 방향으로 "),a("strong",[n._v("서로 다른 비율로")]),n._v(" 확대 또는 축소")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\ns_x & 0 \\\\\n0 & s_y\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix} =\n\\begin{bmatrix}\ns_xx \\\\\ns_yy\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[n._v("(예: $s_x$ = 1.5, $s_y$ = 0.8 → $x$축 방향은 확대, $y$축 방향은 축소)")]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-trans-rotation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-rotation"}},[n._v("#")]),n._v(" 2D Linear Trans. – Rotation")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("회전은 행렬 곱으로 표현 가능하며, 따라서 "),a("strong",[n._v("선형 변환")]),n._v("임")])]),n._v(" "),a("li",[a("p",[n._v("양의 각도는 반시계 방향(CCW, Counter-Clockwise)을 의미함")])])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n\\cos \\theta & -\\sin \\theta \\\\\n\\sin \\theta & \\cos \\theta\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix} =\n\\begin{bmatrix}\nx \\cos \\theta - y \\sin \\theta \\\\\nx \\sin \\theta + y \\cos \\theta\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[n._v("(예: $\\theta = 30\\degree$ → 30도 반시계 회전)")]),n._v(" "),a("h2",{attrs:{id:"numbers-in-matrices-scaling-rotation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#numbers-in-matrices-scaling-rotation"}},[n._v("#")]),n._v(" Numbers in Matrices: Scaling, Rotation")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("행렬의 "),a("strong",[n._v("각 숫자는 어떤 의미를 가질까?")])])]),n._v(" "),a("li",[a("p",[n._v("단위 벡터$([1, 0]^T, [0, 1]^T)$을 기준으로 scaling 또는 rotation 시 각각의 column vector가 변환된 축의 방향을 나타냄")])]),n._v(" "),a("li",[a("p",[n._v("Canonical basis vectors: 직교 좌표계에서 x, y축 방향 단위 벡터")])]),n._v(" "),a("li",[a("p",[n._v("결과적으로, 변환된 좌표계의 축 방향을 나타냄")])]),n._v(" "),a("li",[a("p",[n._v("행렬의 "),a("strong",[n._v("column vector")]),n._v("는 그 행렬의 column space를 구성하는 "),a("strong",[n._v("basis vectors")])])]),n._v(" "),a("li",[a("p",[a("em",[n._v("Column space")]),n._v(": column vector들의 선형 결합으로 표현 가능한 모든 벡터의 집합")])])]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-trans-reflection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-reflection"}},[n._v("#")]),n._v(" 2D Linear Trans. – Reflection")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("Reflection은 "),a("strong",[n._v("non-uniform scaling의 특수한 경우")]),n._v("로 간주할 수 있음")])]),n._v(" "),a("li",[a("p",[n._v("예시: $x$축 방향 reflection")])])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n-1 & 0\\\\\n0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"_2d-linear-trans-shearing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-linear-trans-shearing"}},[n._v("#")]),n._v(" 2D Linear Trans. – Shearing")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("물체를 "),a("strong",[n._v("측면으로 밀기(push sideways)")])])]),n._v(" "),a("li",[a("p",[n._v("예시: $x$축 기준으로 $y$에 비례하여 $x$ 이동")])])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n-1 & 0\\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\\ny\n\\end{bmatrix} =\n\\begin{bmatrix}\nx+ay\\\\\ny\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"identity-matrix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#identity-matrix"}},[n._v("#")]),n._v(" Identity Matrix")]),n._v(" "),a("ul",[a("li",[n._v("아무런 변환도 수행하지 않는 행렬 → "),a("strong",[n._v('"Doing nothing"')])])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n1 & 0\\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\\ny\n\\end{bmatrix} =\n\\begin{bmatrix}\nx\\\\\ny\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[n._v("(도형의 위치, 크기, 방향이 유지됨)")]),n._v(" "),a("h2",{attrs:{id:"demo-2d-linear-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo-2d-linear-transformations"}},[n._v("#")]),n._v(" [Demo] 2D Linear Transformations")]),n._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php"),a("OutboundLink")],1)]),n._v(" "),a("li",[n._v("행렬 요소의 값을 바꿔보세요")]),n._v(" "),a("li",[n._v("다양한 변환 버튼을 눌러보세요")])]),n._v(" "),a("h2",{attrs:{id:"quiz-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quiz-1"}},[n._v("#")]),n._v(" Quiz 1")]),n._v(" "),a("h2",{attrs:{id:"_2d-translation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2d-translation"}},[n._v("#")]),n._v(" 2D Translation")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("Translation은 가장 간단한 변환:"),a("br"),n._v("\n$T(\\mathbf{v}) = \\mathbf{v} + \\mathbf{u}$")])]),n._v(" "),a("li",[a("p",[n._v("역변환(Inverse):"),a("br"),n._v("\n$T^{-1}(\\mathbf{v}) = \\mathbf{v} − \\mathbf{u}$")])])]),n._v(" "),a("p",[n._v("(도식: $\\mathbf{v}$ 벡터에서 $\\mathbf{u}$만큼 이동한 결과가 $T(\\mathbf{v})$)")]),n._v(" "),a("h2",{attrs:{id:"is-translation-linear-transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-translation-linear-transformation"}},[n._v("#")]),n._v(" Is translation linear transformation?")]),n._v(" "),a("ul",[a("li",[a("p",[a("strong",[n._v("아니오. 선형 변환(linear transformation)이 아님")])])]),n._v(" "),a("li",[a("p",[n._v("선형성(linearity)을 만족하지 않음:"),a("br"),n._v("\n$$\nT(\\mathbf{v}_1 + \\mathbf{v}_2) \\neq T(\\mathbf{v}_1) + T(\\mathbf{v}_2) \\\\ T(c\\mathbf{v}) \\neq cT(\\mathbf{v})\n$$")]),n._v(" "),a("p",[n._v("예:")]),n._v(" "),a("p",[n._v("$$\ncT(\\mathbf{v}) = c(\\mathbf{v} + \\mathbf{b}) = c\\mathbf{v} + c\\mathbf{b} \\\\ \\neq T(c\\mathbf{v}) = c\\mathbf{v} + \\mathbf{b}\n$$")])]),n._v(" "),a("li",[a("p",[n._v("벡터 덧셈을 사용해 표현 가능:"),a("br"),n._v("\n$$ T(\\mathbf{v}) = \\mathbf{v} + \\mathbf{u} $$")])]),n._v(" "),a("li",[a("p",[n._v("선형 변환과 결합할 수 있음:"),a("br"),n._v("\n$$ T(\\mathbf{v}) = M\\mathbf{v} + \\mathbf{u} $$")])]),n._v(" "),a("li",[a("p",[n._v("→ "),a("strong",[n._v("Affine transformation")])])])]),n._v(" "),a("h2",{attrs:{id:"let-s-check-again"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-s-check-again"}},[n._v("#")]),n._v(" Let’s check again")]),n._v(" "),a("ul",[a("li",[a("p",[a("strong",[n._v("Linear transformation")])]),n._v(" "),a("ul",[a("li",[n._v("Scaling, Rotation, Reflection, Shearing")]),n._v(" "),a("li",[n._v("행렬 곱셈으로 표현 가능"),a("br"),n._v("\n$$ T(\\mathbf{v}) = M\\mathbf{v} $$")])])]),n._v(" "),a("li",[a("p",[a("strong",[n._v("Translation")])]),n._v(" "),a("ul",[a("li",[n._v("선형 변환이 아님")]),n._v(" "),a("li",[n._v("벡터 덧셈으로 표현됨"),a("br"),n._v("\n$$ T(\\mathbf{v}) = \\mathbf{v} + \\mathbf{u} $$")])])]),n._v(" "),a("li",[a("p",[a("strong",[n._v("Affine transformation")])]),n._v(" "),a("ul",[a("li",[n._v("선형 변환과 translation을 결합한 형태"),a("br"),n._v("\n$$ T(\\mathbf{v}) = M\\mathbf{v} + \\mathbf{u} $$")])])])]),n._v(" "),a("h2",{attrs:{id:"rigid-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rigid-transformations"}},[n._v("#")]),n._v(" Rigid Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("모든 점 사이의 거리를 유지함")]),n._v(" "),a("p",[n._v("$$\n|g(\\mathbf{u}) - g(\\mathbf{v})| = |\\mathbf{u} - \\mathbf{v}|, \\\\ \\forall \\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^3 \\quad (g: \\text{rigid transform map})\n$$")])]),n._v(" "),a("li",[a("p",[n._v('"Handedness"를 보존함:')]),n._v(" "),a("ul",[a("li",[n._v("선형 변환 중 handedness를 보존하는 회전의 조건:"),a("br"),n._v("\n$$\ng(\\mathbf{u}) \\times g(\\mathbf{v}) = g(\\mathbf{u} \\times \\mathbf{v}), \\\\ \\forall \\mathbf{u}, \\mathbf{v} \\in \\mathbb{R}^3\n$$\n"),a("ul",[a("li",[n._v("Reflection은 보존하지 않음")])])]),n._v(" "),a("li",[n._v("Translation은 방향을 바꾸지 않으므로 영향을 주지 않음")])])]),n._v(" "),a("li",[a("p",[n._v("Rigid transformation의 예:")]),n._v(" "),a("ul",[a("li",[n._v("Translation")]),n._v(" "),a("li",[n._v("Identity")]),n._v(" "),a("li",[n._v("Rotation")])])]),n._v(" "),a("li",[a("p",[n._v("일부 문헌에서는 reflection을 rigid로 분류하기도 하나, 본 강의에서는 포함하지 않음")])])]),n._v(" "),a("h2",{attrs:{id:"similarity-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#similarity-transformations"}},[n._v("#")]),n._v(" Similarity Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("각도를 보존함")])]),n._v(" "),a("li",[a("p",[n._v("(rigid transformation도 각도 보존 포함)")])]),n._v(" "),a("li",[a("p",[n._v("Similarity transformation의 예:")]),n._v(" "),a("ul",[a("li",[n._v("Translation")]),n._v(" "),a("li",[n._v("Identity")]),n._v(" "),a("li",[n._v("Rotation")]),n._v(" "),a("li",[a("strong",[n._v("Uniform Scaling")])])])]),n._v(" "),a("li",[a("p",[n._v("일부 문헌에서는 reflection도 포함하나, 본 강의에서는 다루지 않음")])])]),n._v(" "),a("h2",{attrs:{id:"linear-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations"}},[n._v("#")]),n._v(" Linear Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("원점을 보존함")])]),n._v(" "),a("li",[a("p",[n._v("포함되는 변환들:")]),n._v(" "),a("ul",[a("li",[n._v("Translation")]),n._v(" "),a("li",[n._v("Identity")]),n._v(" "),a("li",[n._v("Rotation")]),n._v(" "),a("li",[n._v("Uniform Scaling")]),n._v(" "),a("li",[n._v("Scaling")]),n._v(" "),a("li",[n._v("Reflection")]),n._v(" "),a("li",[n._v("Shearing")])])])]),n._v(" "),a("h2",{attrs:{id:"affine-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#affine-transformations"}},[n._v("#")]),n._v(" Affine Transformations")]),n._v(" "),a("ul",[a("li",[n._v("평행선을 유지함")]),n._v(" "),a("li",[n._v("직선 상의 거리 비율을 유지함")])]),n._v(" "),a("h2",{attrs:{id:"projective-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#projective-transformations"}},[n._v("#")]),n._v(" Projective Transformations")]),n._v(" "),a("ul",[a("li",[n._v("직선을 보존함\n"),a("img",{attrs:{src:"https://kmbzn.com/images/transformations.png",alt:"transformations"}})])]),n._v(" "),a("h2",{attrs:{id:"composition-of-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-of-transformations"}},[n._v("#")]),n._v(" Composition of Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("어떤 물체에 T 변환을 적용한 후, S 변환을 추가 적용:")]),n._v(" "),a("p",[n._v("$$\n\\mathbf{p} \\rightarrow T(\\mathbf{p}) \\rightarrow S(T(\\mathbf{p})) = (S \\circ T)(\\mathbf{p})\n$$")])]),n._v(" "),a("li",[a("p",[n._v("2D linear transformation의 합성은"),a("br"),n._v("\n2×2 행렬 곱셈으로 표현 가능:")]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{p}) = M_T \\mathbf{p}; \\quad S(\\mathbf{p}) = M_S \\mathbf{p}\n$$")]),n._v(" "),a("p",[n._v("$$\n(S \\circ T)(\\mathbf{p}) = M_S M_T \\mathbf{p} \\\\\n= (M_S M_T)\\mathbf{p} = M_S (M_T \\mathbf{p})\n$$")])])]),n._v(" "),a("h2",{attrs:{id:"order-matters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#order-matters"}},[n._v("#")]),n._v(" Order Matters!")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("행렬 곱셈은 결합법칙은 성립하지만 "),a("strong",[n._v("교환법칙은 성립하지 않음")]),n._v(":")]),n._v(" "),a("p",[n._v("$$\n(AB)C = A(BC) \\\\\nAB \\ne BA\n$$")])]),n._v(" "),a("li",[a("p",[n._v("따라서, "),a("strong",[n._v("변환의 적용 순서가 매우 중요함")])])])]),n._v(" "),a("p",[n._v("(예: Scale → Rotate vs Rotate → Scale 결과가 다름)")]),n._v(" "),a("h2",{attrs:{id:"demo-composition-of-linear-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo-composition-of-linear-transformations"}},[n._v("#")]),n._v(" [Demo] Composition of Linear Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://www.integral-domain.org/lwilliams/Applets/algebra/linearTransformations.php"),a("OutboundLink")],1)])]),n._v(" "),a("li",[a("p",[n._v("identity matrix로 초기화 (1 0 0 1 입력)")])]),n._v(" "),a("li",[a("p",[n._v('"Compose Transformations" 버튼 클릭')])]),n._v(" "),a("li",[a("p",[n._v("두 개의 변환을 서로 다른 순서로 적용해보기")])])]),n._v(" "),a("h2",{attrs:{id:"problems-when-handling-translation-as-vector-addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#problems-when-handling-translation-as-vector-addition"}},[n._v("#")]),n._v(" Problems when handling Translation as Vector Addition")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("선형 변환(회전, 스케일 등)과 translation을"),a("br"),n._v(" "),a("strong",[n._v("일관된 방식으로 표현할 수 없음")])])]),n._v(" "),a("li",[a("p",[n._v("Affine 변환의 합성은 복잡해짐:")])])]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{p}) = M_T \\mathbf{p} + \\mathbf{u}_T \\\\\nS(\\mathbf{p}) = M_S \\mathbf{p} + \\mathbf{u}_S\n$$")]),n._v(" "),a("p",[n._v("$$\n(S \\circ T)(\\mathbf{p}) = M_S(M_T \\mathbf{p} + \\mathbf{u}_T) + \\mathbf{u}_S \\\\\n= (M_S M_T) \\mathbf{p} + (M_S \\mathbf{u}_T + \\mathbf{u}_S)\n$$")]),n._v(" "),a("ul",[a("li",[n._v("더 깔끔한 표현 방식이 필요함"),a("br"),n._v("\n→ "),a("strong",[n._v("Homogeneous coordinates")])])]),n._v(" "),a("h2",{attrs:{id:"homogeneous-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#homogeneous-coordinates"}},[n._v("#")]),n._v(" Homogeneous Coordinates")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("핵심 아이디어: 2D 점을 3D 좌표계 상에 표현")])]),n._v(" "),a("li",[a("p",[n._v("벡터에는 추가 성분($w$), 행렬에는 추가 행/열을 추가")]),n._v(" "),a("ul",[a("li",[n._v("점에는 항상 $w = 1$")]),n._v(" "),a("li",[n._v("2D 점 $[x,~y]^T → [x,~y,~1]^T$")])])]),n._v(" "),a("li",[a("p",[n._v("2D linear transformation의 표현:")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\na & b & 0 \\\\\nc & d & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix} =\n\\begin{bmatrix}\nax + by \\\\\ncx + dy \\\\\n1\n\\end{bmatrix}\n$$")])]),n._v(" "),a("li",[a("p",[n._v("2D translation의 표현:")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n1 & 0 & t \\\\\n0 & 1 & s \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix} =\n\\begin{bmatrix}\nx + t \\\\\ny + s \\\\\n1\n\\end{bmatrix}\n$$")])]),n._v(" "),a("li",[a("p",[n._v("2D affine transformation의 표현:")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} & u_x \\\\\nm_{21} & m_{22} & u_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$")])]),n._v(" "),a("li",[a("p",[a("strong",[n._v("Affine transformation 합성")]),n._v("은 "),a("strong",[n._v("3×3 행렬 곱셈")]),n._v("으로 간단하게 처리 가능:")])])]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{p}) = M_T \\mathbf{p} + \\mathbf{u}_T \\\\\nS(\\mathbf{p}) = M_S \\mathbf{p} + \\mathbf{u}_S\n$$")]),n._v(" "),a("p",[n._v("→ block 행렬 표현:")]),n._v(" "),a("p",[n._v("$$\nT(\\mathbf{p}) =\n\\begin{bmatrix}\nM_T & \\mathbf{u}_T \\\\\n0 & 1\n\\end{bmatrix}, \\\\\nS(\\mathbf{p}) =\n\\begin{bmatrix}\nM_S & \\mathbf{u}_S \\\\\n0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[n._v("$$\n(S \\circ T)(\\mathbf{p}) \\\\ =\n\\begin{bmatrix}\nM_S & \\mathbf{u}_S \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\nM_T & \\mathbf{u}_T \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n1\n\\end{bmatrix} \\\\ =\n\\begin{bmatrix}\n(M_S M_T) \\mathbf{p} + (M_S \\mathbf{u}_T + \\mathbf{u}_S) \\\\\n1\n\\end{bmatrix}\n$$")]),n._v(" "),a("ul",[a("li",[n._v("결과는 이전 방식과 같지만, "),a("strong",[n._v("훨씬 간단하고 깔끔함")])])]),n._v(" "),a("blockquote",[a("p",[n._v("cf. 기존 표현과 비교:"),a("br"),n._v("\n$(S \\circ T)(\\mathbf{p}) = M_S(M_T \\mathbf{p} + \\mathbf{u}_T) + \\mathbf{u}_S$"),a("br"),n._v("\n$= (M_S M_T)\\mathbf{p} + (M_S \\mathbf{u}_T + \\mathbf{u}_S)$")])]),n._v(" "),a("h2",{attrs:{id:"demo-composition-of-affine-transformations-in-homogeneous-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#demo-composition-of-affine-transformations-in-homogeneous-coordinates"}},[n._v("#")]),n._v(" [Demo] Composition of Affine Transformations in Homogeneous Coordinates")]),n._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://observablehq.com/@esperanc/transformation-demo",target:"_blank",rel:"noopener noreferrer"}},[n._v("https://observablehq.com/@esperanc/transformation-demo"),a("OutboundLink")],1)])]),n._v(" "),a("li",[a("p",[n._v("‘+’ 버튼으로 다양한 순서의 translation 및 linear transformation 추가")])]),n._v(" "),a("li",[a("p",[n._v("슬라이더로 행렬 값의 변화와 도형 변형 확인")])]),n._v(" "),a("li",[a("p",[n._v("주의: 마지막에 추가된 변환이 "),a("strong",[n._v("가장 먼저 적용")]),n._v("됨")])])]),n._v(" "),a("h2",{attrs:{id:"summary-homogeneous-coordinates-in-2d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary-homogeneous-coordinates-in-2d"}},[n._v("#")]),n._v(" Summary: Homogeneous Coordinates in 2D")]),n._v(" "),a("ul",[a("li",[n._v("2D 점에는 $(x,~y)^T$ 대신 $(x,~y,~1)^T$ 사용")]),n._v(" "),a("li",[n._v("2D linear transformation에는 2×2 행렬 대신 "),a("strong",[n._v("3×3 행렬")]),n._v(" 사용")]),n._v(" "),a("li",[n._v("2D translation에도 벡터 덧셈 대신 "),a("strong",[n._v("3×3 행렬")]),n._v(" 사용")])]),n._v(" "),a("p",[n._v("→ linear transformation과 translation을 "),a("strong",[n._v("일관된 방식으로 처리할 수 있음!")])]),n._v(" "),a("h2",{attrs:{id:"quiz-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quiz-2"}},[n._v("#")]),n._v(" Quiz 2")]),n._v(" "),a("h2",{attrs:{id:"now-let-s-go-to-the-3d-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#now-let-s-go-to-the-3d-world"}},[n._v("#")]),n._v(" Now, Let’s go to the 3D world!")]),n._v(" "),a("ul",[a("li",[n._v("Coordinate system (좌표계)\n"),a("ul",[a("li",[n._v("Cartesian coordinate system (직교좌표계)\n"),a("ul",[a("li",[n._v("2D 좌표계 → z축이 포함된 3D 좌표계로 확장됨")])])])])])]),n._v(" "),a("h2",{attrs:{id:"right-handed-and-left-handed-coordinate-systems"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#right-handed-and-left-handed-coordinate-systems"}},[n._v("#")]),n._v(" Right-Handed and Left-Handed Coordinate Systems")]),n._v(" "),a("ul",[a("li",[n._v("우리가 사용하는 시스템: "),a("strong",[n._v("Right-handed Cartesian Coordinates")])])]),n._v(" "),a("table",[a("thead",[a("tr",[a("th",[n._v("항목")]),n._v(" "),a("th",[n._v("Right-handed")]),n._v(" "),a("th",[n._v("Left-handed")])])]),n._v(" "),a("tbody",[a("tr",[a("td",[n._v("회전 방향")]),n._v(" "),a("td",[n._v("축 기준 반시계 방향")]),n._v(" "),a("td",[n._v("축 기준 시계 방향")])]),n._v(" "),a("tr",[a("td",[n._v("사용 예시")]),n._v(" "),a("td",[a("strong",[n._v("OpenGL")]),n._v(", Maya, Houdini, AutoCAD, Physics & Math")]),n._v(" "),a("td",[n._v("DirectX, Unity, Unreal 등")])])])]),n._v(" "),a("p",[n._v("(이미지: 오른손 법칙과 왼손 법칙 설명)")]),n._v(" "),a("h2",{attrs:{id:"point-representations-in-cartesian-homogeneous-coordinate-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#point-representations-in-cartesian-homogeneous-coordinate-system"}},[n._v("#")]),n._v(" Point Representations in Cartesian & Homogeneous Coordinate System")]),n._v(" "),a("h3",{attrs:{id:"a-2d-point-is-represented-as"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-2d-point-is-represented-as"}},[n._v("#")]),n._v(" A 2D point is represented as:")]),n._v(" "),a("ul",[a("li",[a("p",[a("strong",[n._v("Cartesian coordinate system")]),n._v(":\n$$\n\\begin{bmatrix}\np_x \\\\\np_y\n\\end{bmatrix}\n$$")])]),n._v(" "),a("li",[a("p",[a("strong",[n._v("Homogeneous coordinate system")]),n._v(":\n$$\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\n1\n\\end{bmatrix}\n$$")])])]),n._v(" "),a("hr"),n._v(" "),a("h3",{attrs:{id:"a-3d-point-is-represented-as"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-3d-point-is-represented-as"}},[n._v("#")]),n._v(" A 3D point is represented as:")]),n._v(" "),a("ul",[a("li",[a("p",[a("strong",[n._v("Cartesian coordinate system")]),n._v(":\n$$\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\np_z\n\\end{bmatrix}\n$$")])]),n._v(" "),a("li",[a("p",[a("strong",[n._v("Homogeneous coordinate system")]),n._v(":\n$$\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\np_z \\\\\n1\n\\end{bmatrix}\n$$")])])]),n._v(" "),a("h2",{attrs:{id:"review-of-linear-transformations-in-2d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#review-of-linear-transformations-in-2d"}},[n._v("#")]),n._v(" Review of Linear Transformations in 2D")]),n._v(" "),a("ul",[a("li",[n._v("2D에서의 선형 변환은 다음과 같은 행렬 곱셈으로 표현됨:")])]),n._v(" "),a("h3",{attrs:{id:"_2x2-matrix-in-cartesian-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2x2-matrix-in-cartesian-coordinates"}},[n._v("#")]),n._v(" 2x2 matrix (in Cartesian coordinates):")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} \\\\\nm_{21} & m_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\\np_y\n\\end{bmatrix}\n$$")]),n._v(" "),a("h3",{attrs:{id:"or"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#or"}},[n._v("#")]),n._v(" or")]),n._v(" "),a("h3",{attrs:{id:"_3x3-matrix-in-homogeneous-coordinates"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3x3-matrix-in-homogeneous-coordinates"}},[n._v("#")]),n._v(" 3x3 matrix (in homogeneous coordinates):")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} & 0 \\\\\nm_{21} & m_{22} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\n1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"linear-transformations-in-3d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d"}},[n._v("#")]),n._v(" Linear Transformations in 3D")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("3D에서의 선형 변환은 다음 행렬 곱셈으로 표현됨:")]),n._v(" "),a("p",[n._v("3x3 matrix (in Cartesian coordinates)"),a("br"),n._v("\n또는"),a("br"),n._v("\n4x4 matrix (in homogeneous coordinates)")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} \\\\\nm_{21} & m_{22} & m_{23} \\\\\nm_{31} & m_{32} & m_{33}\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\np_z\n\\end{bmatrix}\n\\\\ \\text{or}\\ \\\\\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} & 0 \\\\\nm_{21} & m_{22} & m_{23} & 0 \\\\\nm_{31} & m_{32} & m_{33} & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\\np_y \\\\\np_z \\\\\n1\n\\end{bmatrix}\n$$")])])]),n._v(" "),a("h2",{attrs:{id:"linear-transformations-in-3d-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d-2"}},[n._v("#")]),n._v(" Linear Transformations in 3D")]),n._v(" "),a("p",[a("strong",[n._v("Scaling (크기 조절):")])]),n._v(" "),a("p",[n._v("$$\nS_s =\n\\begin{bmatrix}\nS_x & 0 & 0 \\\\\n0 & S_y & 0 \\\\\n0 & 0 & S_z\n\\end{bmatrix}\n\\quad\\text{(3D)}\n\\\\\nS_s =\n\\begin{bmatrix}\nS_x & 0 & 0 & 0 \\\\\n0 & S_y & 0 & 0 \\\\\n0 & 0 & S_z & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\quad\\text{(3D-H)}\n$$")]),n._v(" "),a("p",[a("strong",[n._v("Shear (in $x$, based on $z$ position):")])]),n._v(" "),a("p",[n._v("$$\nH_{x,d} =\n\\begin{bmatrix}\n1 & d_y & d_z \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\\\ \\text{or} \\\\\nH_{x,d} =\n\\begin{bmatrix}\n1 & d_y & d_z & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"linear-transformations-in-3d-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#linear-transformations-in-3d-3"}},[n._v("#")]),n._v(" Linear Transformations in 3D")]),n._v(" "),a("p",[a("strong",[n._v("Rotation about $x$-axis:")])]),n._v(" "),a("p",[n._v("$$\nR_{x,\\theta} =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos\\theta & -\\sin\\theta \\\\\n0 & \\sin\\theta & \\cos\\theta\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[a("strong",[n._v("Rotation about $y$-axis:")])]),n._v(" "),a("p",[n._v("$$\nR_{y,\\theta} =\n\\begin{bmatrix}\n\\cos\\theta & 0 & \\sin\\theta \\\\\n0 & 1 & 0 \\\\\n-\\sin\\theta & 0 & \\cos\\theta\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[a("strong",[n._v("Rotation about $z$-axis:")])]),n._v(" "),a("p",[n._v("$$\nR_{z,\\theta} =\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[n._v("(오른손 법칙에 따라 z축을 기준으로 위에서 아래로 보는 시점에서 반시계 방향 회전)")]),n._v(" "),a("h2",{attrs:{id:"review-of-translations-in-2d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#review-of-translations-in-2d"}},[n._v("#")]),n._v(" Review of Translations in 2D")]),n._v(" "),a("ul",[a("li",[n._v("2D에서의 Translation은 다음 두 방식으로 표현 가능:")])]),n._v(" "),a("p",[a("strong",[n._v("Vector addition")]),n._v(" "),a("em",[n._v("(in Cartesian coordinates)")]),n._v(":")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\np_x \\\\ p_y\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nu_x \\\\ u_y\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[a("strong",[n._v("Matrix multiplication")]),n._v(" "),a("em",[n._v("(in homogeneous coordinates)")]),n._v(":")]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n1 & 0 & u_x \\\\\n0 & 1 & u_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\ p_y \\\\ 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"translations-in-3d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#translations-in-3d"}},[n._v("#")]),n._v(" Translations in 3D")]),n._v(" "),a("ul",[a("li",[n._v("3D에서의 Translation도 유사하게 표현 가능:")])]),n._v(" "),a("p",[a("strong",[n._v("Vector addition (Cartesian coordinates):")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\np_x \\\\ p_y \\\\ p_z\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nu_x \\\\ u_y \\\\ u_z\n\\end{bmatrix}\n$$")]),n._v(" "),a("p",[a("strong",[n._v("Matrix multiplication (homogeneous coordinates):")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\n1 & 0 & 0 & u_x \\\\\n0 & 1 & 0 & u_y \\\\\n0 & 0 & 1 & u_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\np_x \\\\ p_y \\\\ p_z \\\\ 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"review-of-affine-transformations-in-2d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#review-of-affine-transformations-in-2d"}},[n._v("#")]),n._v(" Review of Affine Transformations in 2D")]),n._v(" "),a("ul",[a("li",[n._v("Homogeneous coordinates에서는 2D affine transformation을 3×3 행렬 곱으로 표현할 수 있음:")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} & u_x \\\\\nm_{21} & m_{22} & u_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"affine-transformations-in-3d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#affine-transformations-in-3d"}},[n._v("#")]),n._v(" Affine Transformations in 3D")]),n._v(" "),a("ul",[a("li",[n._v("Homogeneous coordinates에서는 3D affine transformation을"),a("br"),n._v("\n4×4 행렬 곱으로 표현할 수 있음:")])]),n._v(" "),a("p",[n._v("$$\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} & u_x \\\\\nm_{21} & m_{22} & m_{23} & u_y \\\\\nm_{31} & m_{32} & m_{33} & u_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$")]),n._v(" "),a("h2",{attrs:{id:"summary-affine-transformation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary-affine-transformation"}},[n._v("#")]),n._v(" Summary: Affine Transformation")]),n._v(" "),a("ul",[a("li",[n._v("$\\mathbf{p}$라는 점 집합에 대해 affine transformation $\\mathbf{M}$을 적용하면:\n$$\n\\mathbf{M} =\n\\begin{bmatrix}\nm_{11} & m_{12} & m_{13} & u_1 \\\\\nm_{21} & m_{22} & m_{23} & u_2 \\\\\nm_{31} & m_{32} & m_{33} & u_3 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$")])]),n._v(" "),a("p",[n._v("$$\n\\mathbf{p}_i' \\leftarrow \\mathbf{M} \\mathbf{p}_i\n$$")]),n._v(" "),a("p",[n._v("$$\n\\mathbf{p}_1' \\leftarrow \\mathbf{M} \\mathbf{p}_1 \\\\\n\\mathbf{p}_2' \\leftarrow \\mathbf{M} \\mathbf{p}_2 \\\\\n\\mathbf{p}_3' \\leftarrow \\mathbf{M} \\mathbf{p}_3 \\\\ \\dots \\\\\n\\mathbf{p}_N' \\leftarrow \\mathbf{M} \\mathbf{p}_N\n$$")]),n._v(" "),a("h2",{attrs:{id:"summary-composition-of-affine-transformations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary-composition-of-affine-transformations"}},[n._v("#")]),n._v(" Summary: Composition of Affine Transformations")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("여러 개의 affine transformation (예: M₁, M₂)을 순차적으로 적용할 수 있음")])]),n._v(" "),a("li",[a("p",[n._v("각 점마다 개별적으로:")])])]),n._v(" "),a("p",[n._v("$$\n\\mathbf{p}_i'' \\leftarrow \\mathbf{M}_2  \\mathbf{M}_1  \\mathbf{p}_i\n$$")]),n._v(" "),a("p",[n._v("$$\n\\mathbf{p}_1'' \\leftarrow \\mathbf{M}_2 \\mathbf{M}_1 \\mathbf{p}_1 \\\\\n\\mathbf{p}_2'' \\leftarrow \\mathbf{M}_2 \\mathbf{M}_1 \\mathbf{p}_2 \\\\\n\\mathbf{p}_3'' \\leftarrow \\mathbf{M}_2 \\mathbf{M}_1 \\mathbf{p}_3 \\\\ \\dots \\\\\n\\mathbf{p}_N'' \\leftarrow \\mathbf{M}_2 \\mathbf{M}_1 \\mathbf{p}_N\n$$")]),n._v(" "),a("home")],1)}),[],!1,null,null,null);a.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{349:function(e,r,t){"use strict";t.r(r);var a=t(30),i=Object(a.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"_2-rendering-basics"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-rendering-basics"}},[e._v("#")]),e._v(" 2 - Rendering Basics")]),e._v(" "),r("h2",{attrs:{id:"outline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#outline"}},[e._v("#")]),e._v(" Outline")]),e._v(" "),r("ul",[r("li",[e._v("Rendering의 기본 개념")]),e._v(" "),r("li",[e._v("Rendering 방식\n"),r("ul",[r("li",[e._v("Rasterization")]),e._v(" "),r("li",[e._v("Ray Tracing")])])])]),e._v(" "),r("h2",{attrs:{id:"basic-concepts-rendering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-rendering"}},[e._v("#")]),e._v(" Basic Concepts: Rendering")]),e._v(" "),r("ul",[r("li",[e._v("Rendering은 "),r("strong",[e._v("컴퓨터 프로그램을 통해 2D 또는 3D 장면(scene)으로부터 이미지를 생성")]),e._v("하는 과정"),r("br"),e._v(" "),r("em",[e._v("(출처: Wikipedia)")])]),e._v(" "),r("li",[e._v("Rendering 결과물은 다음과 같이 저장 가능:\n"),r("ul",[r("li",[e._v("이미지 파일")]),e._v(" "),r("li",[e._v("비디오 파일 (여러 이미지 프레임의 연속)")]),e._v(" "),r("li",[e._v("또는 "),r("em",[e._v("frame buffer")]),e._v("에 저장되어 디스플레이에 출력")])])])]),e._v(" "),r("h2",{attrs:{id:"basic-concepts-frame-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-frame-buffer"}},[e._v("#")]),e._v(" Basic Concepts: Frame Buffer")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Frame buffer")]),e._v("는 raster 디스플레이 장치에 보낼 비트맵 이미지를 저장하는 메모리 영역")]),e._v(" "),r("li",[e._v("frame buffer는 다음과 같은 속성으로 정의됨:\n"),r("ul",[r("li",[e._v("width, height, depth")]),e._v(" "),r("li",[e._v("예: 4K UHD (3840×2160) 해상도, 32bit 컬러 → 3840 × 2160 × 32 bits")])])]),e._v(" "),r("li",[e._v("보통 "),r("strong",[e._v("그래픽 카드의 메모리")]),e._v("에 저장됨")])]),e._v(" "),r("h2",{attrs:{id:"basic-concepts-double-buffering"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-double-buffering"}},[e._v("#")]),e._v(" Basic Concepts: Double Buffering")]),e._v(" "),r("ul",[r("li",[e._v("Rendering과 displaying을 위해 "),r("strong",[e._v("두 개의 frame buffer 사용")]),e._v(" "),r("ul",[r("li",[e._v("이전 이미지가 "),r("em",[e._v("front buffer")]),e._v("에 출력되는 동안 새로운 이미지를 "),r("em",[e._v("back buffer")]),e._v("에 그림")]),e._v(" "),r("li",[e._v("다음 frame이 준비되면 두 버퍼를 "),r("strong",[e._v("swap")])])])]),e._v(" "),r("li",[e._v("→ "),r("strong",[e._v("프레임 속도 향상")]),e._v(", "),r("strong",[e._v("flickering 감소")])]),e._v(" "),r("li",[e._v("대부분의 그래픽 애플리케이션은 "),r("strong",[e._v("double buffering 사용")])])]),e._v(" "),r("h2",{attrs:{id:"basic-concepts-image-plane"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-image-plane"}},[e._v("#")]),e._v(" Basic Concepts: Image Plane")]),e._v(" "),r("ul",[r("li",[e._v("Image plane은 사용자가 가상 3D scene의 렌더링된 이미지를 보는 실제 디스플레이 화면을 개념적으로 나타내는 평면")]),e._v(" "),r("li",[e._v("즉, 화면을 통해 보여지는 이미지를 투영하는 기준이 되는 개념적 위치를 의미")])]),e._v(" "),r("h2",{attrs:{id:"example-of-rendering-a-3d-scene"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#example-of-rendering-a-3d-scene"}},[e._v("#")]),e._v(" Example of Rendering a 3D Scene")]),e._v(" "),r("ul",[r("li",[e._v("3D Scene 예시 (Camera 위치에서 image plane을 통해 scene이 렌더링됨)")]),e._v(" "),r("li",[e._v("Rendering output 예시\n"),r("ul",[r("li",[e._v('(이 이미지는 Colin Behrens가 제작한 Blender 데모 장면 "Loro Mask"를 렌더링한 결과)')])])])]),e._v(" "),r("h2",{attrs:{id:"render-output"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#render-output"}},[e._v("#")]),e._v(" Render Output")]),e._v(" "),r("ul",[r("li",[e._v("렌더링 결과는 "),r("strong",[e._v("picture elements 또는 pixels")]),e._v("로 구성된 "),r("strong",[e._v("2D 이미지")])]),e._v(" "),r("li",[e._v("즉, 렌더링이란 "),r("strong",[e._v("3D 장면 정보에 기반하여 각 픽셀의 색상을 계산하는 과정")])])]),e._v(" "),r("h2",{attrs:{id:"rendering-approaches"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rendering-approaches"}},[e._v("#")]),e._v(" Rendering Approaches")]),e._v(" "),r("ul",[r("li",[e._v("각 픽셀의 색상을 어떻게 계산할 것인가?")]),e._v(" "),r("li",[e._v("Rasterization")]),e._v(" "),r("li",[e._v("Ray Tracing")]),e._v(" "),r("li",[e._v("학습 기반 장면 표현 방법:\n"),r("ul",[r("li",[r("strong",[e._v("NeRF")]),e._v(": 암시적 3D 장면 표현 학습")]),e._v(" "),r("li",[r("strong",[e._v("Gaussian Splatting")]),e._v(": 포인트 기반 3D 장면 표현 학습")])])])]),e._v(" "),r("h2",{attrs:{id:"rasterization"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization"}},[e._v("#")]),e._v(" Rasterization")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Primitive-by-primitive 방식")]),e._v(" "),r("ul",[r("li",[e._v("primitive 예시: triangle, line, point 등")]),e._v(" "),r("li",[e._v("각 primitive는 이미지 내 어느 픽셀에 영향을 미치는지를 결정하고 해당 픽셀의 색을 설정함")])])])]),e._v(" "),r("div",{staticClass:"language-py extra-class"},[r("pre",{pre:!0,attrs:{class:"language-py"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" each primitive "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("in")]),e._v(" scene "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    transform the primitive to viewport\n    find pixels "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" the primitive\n    "),r("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("set")]),e._v(" color of the pixels based on texture "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("and")]),e._v(" lighting model\n")])])]),r("ul",[r("li",[e._v("예시: 삼각형 하나가 화면에 렌더링됨")])]),e._v(" "),r("h2",{attrs:{id:"rasterization-pipeline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-pipeline"}},[e._v("#")]),e._v(" Rasterization Pipeline")]),e._v(" "),r("p",[e._v("(3D 장면의 기하 정보를 픽셀 단위의 2D 이미지로 변환하는 일련의 처리 과정)")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("흔히 "),r("strong",[e._v("rendering pipeline 또는 graphics pipeline")]),e._v("이라 부름")])]),e._v(" "),r("li",[r("p",[e._v("주요 단계:")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Vertex Processing")]),e._v(" "),r("ul",[r("li",[e._v("vertex를 screen space로 변환")])])]),e._v(" "),r("li",[r("strong",[e._v("Primitive Processing")]),e._v(" "),r("ul",[r("li",[e._v("vertex들을 polygon으로 구성")])])]),e._v(" "),r("li",[r("strong",[e._v("Scan Conversion")]),e._v(" "),r("ul",[r("li",[e._v("polygon을 fragment 집합으로 변환")])])]),e._v(" "),r("li",[r("strong",[e._v("Fragment Processing")]),e._v(" "),r("ul",[r("li",[e._v("각 fragment의 색상 결정 (텍스처, 조명 모델 등 고려)")])])]),e._v(" "),r("li",[r("strong",[e._v("Per-sample Operations")]),e._v(" "),r("ul",[r("li",[e._v("depth test, alpha blending 등 수행")])])])])])]),e._v(" "),r("blockquote",[r("p",[r("strong",[e._v("fragment")]),e._v(": 픽셀을 구성하기 위한 잠정적인 데이터 단위. 하나의 픽셀에 여러 fragment가 생성될 수 있음."),r("br"),e._v("\n예: **MSAA(Multisample Anti-Aliasing)**에서는 하나의 픽셀을 여러 샘플 지점으로 나누어 각각 fragment를 생성하고, 이를 평균 내어 최종 색상을 결정함.")])]),e._v(" "),r("ul",[r("li",[e._v("입력: 각 오브젝트 공간의 vertex")]),e._v(" "),r("li",[e._v("처리 순서:\n"),r("ul",[r("li",[e._v("screen space의 vertex")]),e._v(" "),r("li",[e._v("screen space의 primitive")]),e._v(" "),r("li",[e._v("pixel당 하나 이상의 fragment")]),e._v(" "),r("li",[e._v("색상 계산된 shaded fragments")]),e._v(" "),r("li",[e._v("최종 출력: image")])])])]),e._v(" "),r("h2",{attrs:{id:"ray-tracing-레이-트레이싱"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ray-tracing-레이-트레이싱"}},[e._v("#")]),e._v(" Ray Tracing 레이 트레이싱")]),e._v(" "),r("ul",[r("li",[r("em",[e._v("Pixel-by-pixel")]),e._v(" 방식")]),e._v(" "),r("li",[e._v("카메라 위치에서 image plane 상의 각 픽셀을 통과하는 ray를 생성")]),e._v(" "),r("li",[e._v("해당 ray가 어떤 오브젝트와 교차하는지에 따라 픽셀의 색상이 결정됨")])]),e._v(" "),r("div",{staticClass:"language-py extra-class"},[r("pre",{pre:!0,attrs:{class:"language-py"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" each pixel "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("in")]),e._v(" image"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("plane"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n  determine which "),r("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("object")]),e._v(" should be shown at the pixel\n  "),r("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("set")]),e._v(" color of the pixel based on texture "),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("and")]),e._v(" lighting model\n")])])]),r("ul",[r("li",[e._v("예시: ray 교차 결과가 화면에 렌더링됨")]),e._v(" "),r("li",[e._v("Ray tracing에 대한 자세한 설명은 다음 자료 참고:\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://raytracing.github.io/books/RayTracingInOneWeekend.html",target:"_blank",rel:"noopener noreferrer"}},[e._v('"Ray Tracing in One Weekend"'),r("OutboundLink")],1)])])])]),e._v(" "),r("h2",{attrs:{id:"rasterization-vs-ray-tracing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-vs-ray-tracing"}},[e._v("#")]),e._v(" Rasterization vs. Ray Tracing")]),e._v(" "),r("ul",[r("li",[e._v("(Nvidia에서 제공한 비교 시각화 자료)")])]),e._v(" "),r("h2",{attrs:{id:"rasterization-pros-cons"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rasterization-pros-cons"}},[e._v("#")]),e._v(" Rasterization – Pros & Cons")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("장점")]),e._v(" "),r("ul",[r("li",[e._v("삼각형 스트림만 렌더링하면 되므로 전체 장면 데이터를 유지할 필요가 없음")]),e._v(" "),r("li",[e._v("병렬 처리에 적합 → "),r("strong",[e._v("빠름!")])])])]),e._v(" "),r("li",[r("strong",[e._v("단점")]),e._v(" "),r("ul",[r("li",[e._v("그림자, 반사, 투명도에 대한 일관된 처리 방식이 없음")]),e._v(" "),r("li",[e._v("상대적으로 낮은 품질의 결과물")])])]),e._v(" "),r("li",[e._v("전통적으로 "),r("strong",[e._v("실시간 렌더링")]),e._v("에 사용\n"),r("ul",[r("li",[e._v("예: OpenGL 또는 DirectX 기반의 게임")])])])]),e._v(" "),r("h2",{attrs:{id:"ray-tracing-pros-cons"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ray-tracing-pros-cons"}},[e._v("#")]),e._v(" Ray Tracing – Pros & Cons")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("장점")]),e._v(" "),r("ul",[r("li",[e._v("그림자, 반사, 투명도 처리 등에서 일반화된 방식 제공"),r("br"),e._v("\n→ Ray와의 교차로 처리됨")]),e._v(" "),r("li",[r("strong",[e._v("고품질 결과물 생성 가능")])])])]),e._v(" "),r("li",[r("strong",[e._v("단점 (전통적 관점)")]),e._v(" "),r("ul",[r("li",[e._v("실시간 애플리케이션에 너무 느림")]),e._v(" "),r("li",[e._v("하드웨어 구현이 어려움")])])]),e._v(" "),r("li",[r("strong",[e._v("전통적으로 영화용 오프라인 렌더링에 사용됨")]),e._v(" "),r("ul",[r("li",[e._v("예: Maya, Blender 등의 3D 저작 툴을 사용한 애니메이션 영화")])])])]),e._v(" "),r("h2",{attrs:{id:"recent-ray-tracing-technology"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#recent-ray-tracing-technology"}},[e._v("#")]),e._v(" Recent Ray Tracing Technology")]),e._v(" "),r("ul",[r("li",[e._v("그러나 이 단점들은 더 이상 완전히 사실이 아님\n"),r("ul",[r("li",[e._v("Rasterization보다는 느리지만, "),r("strong",[e._v("real-time도 가능할 만큼 충분히 빠름")])]),e._v(" "),r("li",[e._v("(Rasterization에 비해) 구현은 여전히 어렵지만, "),r("strong",[e._v("하드웨어가 뒷받침됨")])])])]),e._v(" "),r("li",[r("strong",[e._v("지금은 다음과 같은 것들이 가능")]),e._v(":\n"),r("ul",[r("li",[e._v("Nvidia RTX 시리즈와 같은 하드웨어")]),e._v(" "),r("li",[e._v("DirectX Raytracing, Vulkan RT 등의 API")])])]),e._v(" "),r("li",[r("strong",[e._v("최근 변화된 흐름")]),e._v(" "),r("ul",[r("li",[e._v("최초의 실시간 ray tracing 데모 “Reflections”가 "),r("strong",[e._v("2018년 3월에 발표")]),r("br"),e._v(" "),r("iframe",{attrs:{width:"560",height:"315",src:"https://www.youtube.com/embed/lMSuGoYcT3s",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""}})])])])]),e._v(" "),r("h2",{attrs:{id:"in-this-course"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#in-this-course"}},[e._v("#")]),e._v(" In This Course,")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("강의는 "),r("strong",[e._v("모든 렌더링 방식에 공통되는")]),e._v(" computer graphics의 기본 개념에 초점을 맞춤")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Movement & placement")]),e._v(":"),r("br"),e._v("\nTransformations, Hierarchical Modeling, Orientation & Rotation,"),r("br"),e._v("\nKinematics & Animation, Curves")]),e._v(" "),r("li",[r("strong",[e._v("Shape & appearance")]),e._v(":"),r("br"),e._v("\nMesh, Lighting, Texture Mapping, Curves")])])]),e._v(" "),r("li",[r("p",[e._v("일부 강의는 "),r("strong",[e._v("rasterization에 특화된 개념")]),e._v("도 다룸")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("2D 화면으로의 mapping 과정")]),e._v(" "),r("ul",[r("li",[e._v("Viewing / Projection / Viewport 변환")])])]),e._v(" "),r("li",[r("strong",[e._v("형상 표현")]),e._v(" "),r("ul",[r("li",[e._v("Polygon shading")])])]),e._v(" "),r("li",[r("strong",[e._v("Rasterization 처리 절차")]),e._v(" "),r("ul",[r("li",[e._v("Rasterization pipeline, Scan Conversion, Visibility")])])])])]),e._v(" "),r("li",[r("p",[e._v("Lab에서는 여전히 널리 쓰이는 "),r("strong",[e._v("modern OpenGL")]),e._v(" 사용")]),e._v(" "),r("ul",[r("li",[e._v("강의에서 배운 개념 복습용 도구로 사용됨")])])]),e._v(" "),r("li",[r("p",[e._v("이 수업에서는 "),r("strong",[e._v("ray tracing 또는 learnable scene representation을 다루지 않음")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("실시간 렌더링에서 rasterization은 여전히 중요")])]),e._v(" "),r("li",[e._v("다룰 시간이 부족함")])])])]),e._v(" "),r("home")],1)}),[],!1,null,null,null);r.default=i.exports}}]);